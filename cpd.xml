<?xml version="1.0" encoding="UTF-8"?>
<pmd-cpd>
<duplication lines="400" tokens="2198">
<file line="56" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMariadb.java"/>
<file line="56" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<codefragment>
<![CDATA[
	public DbModelMariadb(String dbserver, String dbuser, String dbpasswd)
			throws WaarpDatabaseNoConnectionException {
		super(dbserver, dbuser, dbpasswd);
	}

	private final ReentrantLock lock = new ReentrantLock();

	@Override
	public void createTables(DbSession session) throws WaarpDatabaseNoConnectionException {
		// Create tables: configuration, hosts, rules, runner, cptrunner
		String createTableH2 = "CREATE TABLE IF NOT EXISTS ";
		String primaryKey = " PRIMARY KEY ";
		String notNull = " NOT NULL ";

		// Multiple Mode
		String action = createTableH2 + DbMultipleMonitor.table + "(";
		DbMultipleMonitor.Columns[] mcolumns = DbMultipleMonitor.Columns
				.values();
		for (int i = 0; i < mcolumns.length - 1; i++) {
			action += mcolumns[i].name() +
					DBType.getType(DbMultipleMonitor.dbTypes[i]) + notNull +
					", ";
		}
		action += mcolumns[mcolumns.length - 1].name() +
				DBType.getType(DbMultipleMonitor.dbTypes[mcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		DbRequest request = new DbRequest(session);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}
		DbMultipleMonitor multipleMonitor = new DbMultipleMonitor(session,
				Configuration.configuration.HOST_ID, 0, 0, 0);
		try {
			if (!multipleMonitor.exist())
				multipleMonitor.insert();
		} catch (WaarpDatabaseException e1) {
			e1.printStackTrace();
		}

		// Configuration
		action = createTableH2 + DbConfiguration.table + "(";
		DbConfiguration.Columns[] ccolumns = DbConfiguration.Columns
				.values();
		for (int i = 0; i < ccolumns.length - 1; i++) {
			action += ccolumns[i].name() +
					DBType.getType(DbConfiguration.dbTypes[i]) + notNull +
					", ";
		}
		action += ccolumns[ccolumns.length - 1].name() +
				DBType.getType(DbConfiguration.dbTypes[ccolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		request = new DbRequest(session);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// HostConfiguration
		action = createTableH2 + DbHostConfiguration.table + "(";
		DbHostConfiguration.Columns[] chcolumns = DbHostConfiguration.Columns
				.values();
		for (int i = 0; i < chcolumns.length - 1; i++) {
			action += chcolumns[i].name() +
					DBType.getType(DbHostConfiguration.dbTypes[i]) + notNull +
					", ";
		}
		action += chcolumns[chcolumns.length - 1].name() +
				DBType.getType(DbHostConfiguration.dbTypes[chcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		request = new DbRequest(session);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			// XXX FIX no return;
		} finally {
			request.close();
		}
		
		// hosts
		action = createTableH2 + DbHostAuth.table + "(";
		DbHostAuth.Columns[] hcolumns = DbHostAuth.Columns.values();
		for (int i = 0; i < hcolumns.length - 1; i++) {
			action += hcolumns[i].name() +
					DBType.getType(DbHostAuth.dbTypes[i]) + notNull + ", ";
		}
		action += hcolumns[hcolumns.length - 1].name() +
				DBType.getType(DbHostAuth.dbTypes[hcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// rules
		action = createTableH2 + DbRule.table + "(";
		DbRule.Columns[] rcolumns = DbRule.Columns.values();
		for (int i = 0; i < rcolumns.length - 1; i++) {
			action += rcolumns[i].name() +
					DBType.getType(DbRule.dbTypes[i]) + ", ";
		}
		action += rcolumns[rcolumns.length - 1].name() +
				DBType.getType(DbRule.dbTypes[rcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// runner
		action = createTableH2 + DbTaskRunner.table + "(";
		DbTaskRunner.Columns[] acolumns = DbTaskRunner.Columns.values();
		for (int i = 0; i < acolumns.length; i++) {
			action += acolumns[i].name() +
					DBType.getType(DbTaskRunner.dbTypes[i]) + notNull + ", ";
		}
		// Several columns for primary key
		action += " CONSTRAINT runner_pk " + primaryKey + "(";
		for (int i = DbTaskRunner.NBPRKEY; i > 1; i--) {
			action += acolumns[acolumns.length - i].name() + ",";
		}
		action += acolumns[acolumns.length - 1].name() + "))";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}
		// Index Runner
		action = "CREATE INDEX IDX_RUNNER ON " + DbTaskRunner.table + "(";
		DbTaskRunner.Columns[] icolumns = DbTaskRunner.indexes;
		for (int i = 0; i < icolumns.length - 1; i++) {
			action += icolumns[i].name() + ", ";
		}
		action += icolumns[icolumns.length - 1].name() + ")";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// cptrunner
		/*
		 * # Table to handle any number of sequences: CREATE TABLE Sequences ( name VARCHAR(22) NOT
		 * NULL, seq INT UNSIGNED NOT NULL, # (or BIGINT) PRIMARY KEY name ); # Create a Sequence:
		 * INSERT INTO Sequences (name, seq) VALUES (?, 0); # Drop a Sequence: DELETE FROM Sequences
		 * WHERE name = ?; # Get a sequence number: UPDATE Sequences SET seq = LAST_INSERT_ID(seq +
		 * 1) WHERE name = ?; $seq = $db->LastInsertId();
		 */
		action = "CREATE TABLE Sequences (name VARCHAR(22) NOT NULL PRIMARY KEY," +
				"seq BIGINT NOT NULL)";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}
		action = "INSERT INTO Sequences (name, seq) VALUES ('" + DbTaskRunner.fieldseq + "', " +
				(DbConstant.ILLEGALVALUE + 1) + ")";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}
	}

	public boolean upgradeDb(DbSession session, String version) throws WaarpDatabaseNoConnectionException {
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_13.getVersion())) {
			System.out.println(version+" to "+R66Versions.V2_4_13.getVersion()+"? "+true);
			String createTableH2 = "CREATE TABLE IF NOT EXISTS ";
			String primaryKey = " PRIMARY KEY ";
			String notNull = " NOT NULL ";
	
			// HostConfiguration
			String action = createTableH2 + DbHostConfiguration.table + "(";
			DbHostConfiguration.Columns[] chcolumns = DbHostConfiguration.Columns
					.values();
			for (int i = 0; i < chcolumns.length - 1; i++) {
				action += chcolumns[i].name() +
						DBType.getType(DbHostConfiguration.dbTypes[i]) + notNull +
						", ";
			}
			action += chcolumns[chcolumns.length - 1].name() +
					DBType.getType(DbHostConfiguration.dbTypes[chcolumns.length - 1]) +
					primaryKey + ")";
			System.out.println(action);
			DbRequest request = new DbRequest(session);
			try {
				request.query(action);
			} catch (WaarpDatabaseSqlException e) {
				e.printStackTrace();
				return false;
			} finally {
				request.close();
			}
		}
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_17.getVersion())) {
			System.out.println(version+" to "+R66Versions.V2_4_17.getVersion()+"? "+true);
			DbRequest request = new DbRequest(session);
			try {
				String command = "ALTER TABLE "
						+ DbTaskRunner.table
						+ " ADD COLUMN "
						+
						DbTaskRunner.Columns.TRANSFERINFO.name()
						+ " "
						+
						DBType.getType(DbTaskRunner.dbTypes[DbTaskRunner.Columns.TRANSFERINFO
								.ordinal()]) +
						" AFTER " + DbTaskRunner.Columns.FILEINFO.name();
				request.query(command);
			} catch (WaarpDatabaseSqlException e) {
				e.printStackTrace();
				return false;
			} finally {
				request.close();
			}
		}
		return true;
	}
	
	/*
	 * (non-Javadoc)
	 * @see org.waarp.openr66.databaseold.model.DbModel#resetSequence()
	 */
	@Override
	public void resetSequence(DbSession session, long newvalue)
			throws WaarpDatabaseNoConnectionException {
		String action = "UPDATE Sequences SET seq = " + newvalue +
				" WHERE name = '" + DbTaskRunner.fieldseq + "'";
		DbRequest request = new DbRequest(session);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			return;
		} finally {
			request.close();
		}
		System.out.println(action);
	}

	/*
	 * (non-Javadoc)
	 * @see org.waarp.openr66.databaseold.model.DbModel#nextSequence()
	 */
	@Override
	public synchronized long nextSequence(DbSession dbSession)
			throws WaarpDatabaseNoConnectionException,
			WaarpDatabaseSqlException, WaarpDatabaseNoDataException {
		lock.lock();
		try {
			long result = DbConstant.ILLEGALVALUE;
			String action = "SELECT seq FROM Sequences WHERE name = '" +
					DbTaskRunner.fieldseq + "' FOR UPDATE";
			DbPreparedStatement preparedStatement = new DbPreparedStatement(
					dbSession);
			try {
				dbSession.conn.setAutoCommit(false);
			} catch (SQLException e1) {
			}
			try {
				preparedStatement.createPrepareStatement(action);
				// Limit the search
				preparedStatement.executeQuery();
				if (preparedStatement.getNext()) {
					try {
						result = preparedStatement.getResultSet().getLong(1);
					} catch (SQLException e) {
						throw new WaarpDatabaseSqlException(e);
					}
				} else {
					throw new WaarpDatabaseNoDataException(
							"No sequence found. Must be initialized first");
				}
			} finally {
				preparedStatement.realClose();
			}
			action = "UPDATE Sequences SET seq = " + (result + 1) +
					" WHERE name = '" + DbTaskRunner.fieldseq + "'";
			try {
				preparedStatement.createPrepareStatement(action);
				// Limit the search
				preparedStatement.executeUpdate();
			} finally {
				preparedStatement.realClose();
			}
			return result;
		} finally {
			try {
				dbSession.conn.setAutoCommit(true);
			} catch (SQLException e1) {
			}
			lock.unlock();
		}
	}
	
	public boolean needUpgradeDb(DbSession session, String version, boolean tryFix)
			throws WaarpDatabaseNoConnectionException {
		// Check if the database is up to date
		DbRequest request = null;
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_13.getVersion())) {
			try {
				request = new DbRequest(session);
				request.select("select "+DbHostConfiguration.Columns.HOSTID.name()+" from "+DbHostConfiguration.table+
						" where "+DbHostConfiguration.Columns.HOSTID+" = '"+Configuration.configuration.HOST_ID+"'");
				request.close();
				DbHostConfiguration.updateVersionDb(session, Configuration.configuration.HOST_ID, R66Versions.V2_4_13.getVersion());
			} catch (WaarpDatabaseSqlException e) {
				return ! upgradeDb(session, version);
			} finally {
				if (request != null) {
					request.close();
				}
			}
		}
		request = null;
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_17.getVersion())) {
			try {
				request = new DbRequest(session);
				request.select("select "+DbTaskRunner.Columns.TRANSFERINFO.name()+" from "+DbTaskRunner.table+
						" where "+DbTaskRunner.Columns.SPECIALID+" = "+DbConstant.ILLEGALVALUE);
				request.close();
				DbHostConfiguration.updateVersionDb(session, Configuration.configuration.HOST_ID, R66Versions.V2_4_17.getVersion());
			} catch (WaarpDatabaseSqlException e) {
				return ! upgradeDb(session, version);
			} finally {
				if (request != null) {
					request.close();
				}
			}
		}
		return false;
	}

}
]]>
</codefragment>
</duplication>
<duplication lines="187" tokens="1110">
<file line="67" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMariadb.java"/>
<file line="67" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="60" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
		String primaryKey = " PRIMARY KEY ";
		String notNull = " NOT NULL ";

		// Multiple Mode
		String action = createTableH2 + DbMultipleMonitor.table + "(";
		DbMultipleMonitor.Columns[] mcolumns = DbMultipleMonitor.Columns
				.values();
		for (int i = 0; i < mcolumns.length - 1; i++) {
			action += mcolumns[i].name() +
					DBType.getType(DbMultipleMonitor.dbTypes[i]) + notNull +
					", ";
		}
		action += mcolumns[mcolumns.length - 1].name() +
				DBType.getType(DbMultipleMonitor.dbTypes[mcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		DbRequest request = new DbRequest(session);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}
		DbMultipleMonitor multipleMonitor = new DbMultipleMonitor(session,
				Configuration.configuration.HOST_ID, 0, 0, 0);
		try {
			if (!multipleMonitor.exist())
				multipleMonitor.insert();
		} catch (WaarpDatabaseException e1) {
			e1.printStackTrace();
		}

		// Configuration
		action = createTableH2 + DbConfiguration.table + "(";
		DbConfiguration.Columns[] ccolumns = DbConfiguration.Columns
				.values();
		for (int i = 0; i < ccolumns.length - 1; i++) {
			action += ccolumns[i].name() +
					DBType.getType(DbConfiguration.dbTypes[i]) + notNull +
					", ";
		}
		action += ccolumns[ccolumns.length - 1].name() +
				DBType.getType(DbConfiguration.dbTypes[ccolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		request = new DbRequest(session);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// HostConfiguration
		action = createTableH2 + DbHostConfiguration.table + "(";
		DbHostConfiguration.Columns[] chcolumns = DbHostConfiguration.Columns
				.values();
		for (int i = 0; i < chcolumns.length - 1; i++) {
			action += chcolumns[i].name() +
					DBType.getType(DbHostConfiguration.dbTypes[i]) + notNull +
					", ";
		}
		action += chcolumns[chcolumns.length - 1].name() +
				DBType.getType(DbHostConfiguration.dbTypes[chcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		request = new DbRequest(session);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			// XXX FIX no return;
		} finally {
			request.close();
		}
		
		// hosts
		action = createTableH2 + DbHostAuth.table + "(";
		DbHostAuth.Columns[] hcolumns = DbHostAuth.Columns.values();
		for (int i = 0; i < hcolumns.length - 1; i++) {
			action += hcolumns[i].name() +
					DBType.getType(DbHostAuth.dbTypes[i]) + notNull + ", ";
		}
		action += hcolumns[hcolumns.length - 1].name() +
				DBType.getType(DbHostAuth.dbTypes[hcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// rules
		action = createTableH2 + DbRule.table + "(";
		DbRule.Columns[] rcolumns = DbRule.Columns.values();
		for (int i = 0; i < rcolumns.length - 1; i++) {
			action += rcolumns[i].name() +
					DBType.getType(DbRule.dbTypes[i]) + ", ";
		}
		action += rcolumns[rcolumns.length - 1].name() +
				DBType.getType(DbRule.dbTypes[rcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// runner
		action = createTableH2 + DbTaskRunner.table + "(";
		DbTaskRunner.Columns[] acolumns = DbTaskRunner.Columns.values();
		for (int i = 0; i < acolumns.length; i++) {
			action += acolumns[i].name() +
					DBType.getType(DbTaskRunner.dbTypes[i]) + notNull + ", ";
		}
		// Several columns for primary key
		action += " CONSTRAINT runner_pk " + primaryKey + "(";
		for (int i = DbTaskRunner.NBPRKEY; i > 1; i--) {
			action += acolumns[acolumns.length - i].name() + ",";
		}
		action += acolumns[acolumns.length - 1].name() + "))";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}
		// Index Runner
		action = "CREATE INDEX IDX_RUNNER ON " + DbTaskRunner.table + "(";
		DbTaskRunner.Columns[] icolumns = DbTaskRunner.indexes;
		for (int i = 0; i < icolumns.length - 1; i++) {
			action += icolumns[i].name() + ", ";
		}
		action += icolumns[icolumns.length - 1].name() + ")";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// cptrunner
		/*
		 * # Table to handle any number of sequences: CREATE TABLE Sequences ( name VARCHAR(22) NOT
		 * NULL, seq INT UNSIGNED NOT NULL, # (or BIGINT) PRIMARY KEY name ); # Create a Sequence:
		 * INSERT INTO Sequences (name, seq) VALUES (?, 0); # Drop a Sequence: DELETE FROM Sequences
		 * WHERE name = ?; # Get a sequence number: UPDATE Sequences SET seq = LAST_INSERT_ID(seq +
		 * 1) WHERE name = ?; $seq = $db->LastInsertId();
		 */
		action = "CREATE TABLE Sequences (name VARCHAR(22) NOT NULL PRIMARY KEY," +
]]>
</codefragment>
</duplication>
<duplication lines="165" tokens="1016">
<file line="60" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="63" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMariadb.java"/>
<file line="63" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<codefragment>
<![CDATA[
	@Override
	public void createTables(DbSession session) throws WaarpDatabaseNoConnectionException {
		// Create tables: configuration, hosts, rules, runner, cptrunner
		String createTableH2 = "CREATE TABLE IF NOT EXISTS ";
		String primaryKey = " PRIMARY KEY ";
		String notNull = " NOT NULL ";

		// Multiple Mode
		String action = createTableH2 + DbMultipleMonitor.table + "(";
		DbMultipleMonitor.Columns[] mcolumns = DbMultipleMonitor.Columns
				.values();
		for (int i = 0; i < mcolumns.length - 1; i++) {
			action += mcolumns[i].name() +
					DBType.getType(DbMultipleMonitor.dbTypes[i]) + notNull +
					", ";
		}
		action += mcolumns[mcolumns.length - 1].name() +
				DBType.getType(DbMultipleMonitor.dbTypes[mcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		DbRequest request = new DbRequest(session);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}
		DbMultipleMonitor multipleMonitor = new DbMultipleMonitor(session,
				Configuration.configuration.HOST_ID, 0, 0, 0);
		try {
			if (!multipleMonitor.exist())
				multipleMonitor.insert();
		} catch (WaarpDatabaseException e1) {
			e1.printStackTrace();
		}

		// Configuration
		action = createTableH2 + DbConfiguration.table + "(";
		DbConfiguration.Columns[] ccolumns = DbConfiguration.Columns
				.values();
		for (int i = 0; i < ccolumns.length - 1; i++) {
			action += ccolumns[i].name() +
					DBType.getType(DbConfiguration.dbTypes[i]) + notNull +
					", ";
		}
		action += ccolumns[ccolumns.length - 1].name() +
				DBType.getType(DbConfiguration.dbTypes[ccolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		request = new DbRequest(session);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// HostConfiguration
		action = createTableH2 + DbHostConfiguration.table + "(";
		DbHostConfiguration.Columns[] chcolumns = DbHostConfiguration.Columns
				.values();
		for (int i = 0; i < chcolumns.length - 1; i++) {
			action += chcolumns[i].name() +
					DBType.getType(DbHostConfiguration.dbTypes[i]) + notNull +
					", ";
		}
		action += chcolumns[chcolumns.length - 1].name() +
				DBType.getType(DbHostConfiguration.dbTypes[chcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		request = new DbRequest(session);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			// XXX FIX no return;
		} finally {
			request.close();
		}
				
		// hosts
		action = createTableH2 + DbHostAuth.table + "(";
		DbHostAuth.Columns[] hcolumns = DbHostAuth.Columns.values();
		for (int i = 0; i < hcolumns.length - 1; i++) {
			action += hcolumns[i].name() +
					DBType.getType(DbHostAuth.dbTypes[i]) + notNull + ", ";
		}
		action += hcolumns[hcolumns.length - 1].name() +
				DBType.getType(DbHostAuth.dbTypes[hcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// rules
		action = createTableH2 + DbRule.table + "(";
		DbRule.Columns[] rcolumns = DbRule.Columns.values();
		for (int i = 0; i < rcolumns.length - 1; i++) {
			action += rcolumns[i].name() +
					DBType.getType(DbRule.dbTypes[i]) + ", ";
		}
		action += rcolumns[rcolumns.length - 1].name() +
				DBType.getType(DbRule.dbTypes[rcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// runner
		action = createTableH2 + DbTaskRunner.table + "(";
		DbTaskRunner.Columns[] acolumns = DbTaskRunner.Columns.values();
		for (int i = 0; i < acolumns.length; i++) {
			action += acolumns[i].name() +
					DBType.getType(DbTaskRunner.dbTypes[i]) + notNull + ", ";
		}
		// Several columns for primary key
		action += " CONSTRAINT runner_pk " + primaryKey + "(";
		for (int i = DbTaskRunner.NBPRKEY; i > 1; i--) {
			action += acolumns[acolumns.length - i].name() + ",";
		}
		action += acolumns[acolumns.length - 1].name() + "))";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}
		// Index Runner
		action = "CREATE INDEX IF NOT EXISTS IDX_RUNNER ON " + DbTaskRunner.table + "(";
]]>
</codefragment>
</duplication>
<duplication lines="161" tokens="1000">
<file line="64" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="60" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
		String primaryKey = " PRIMARY KEY ";
		String notNull = " NOT NULL ";

		// Multiple Mode
		String action = createTableH2 + DbMultipleMonitor.table + "(";
		DbMultipleMonitor.Columns[] mcolumns = DbMultipleMonitor.Columns
				.values();
		for (int i = 0; i < mcolumns.length - 1; i++) {
			action += mcolumns[i].name() +
					DBType.getType(DbMultipleMonitor.dbTypes[i]) + notNull +
					", ";
		}
		action += mcolumns[mcolumns.length - 1].name() +
				DBType.getType(DbMultipleMonitor.dbTypes[mcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		DbRequest request = new DbRequest(session);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}
		DbMultipleMonitor multipleMonitor = new DbMultipleMonitor(session,
				Configuration.configuration.HOST_ID, 0, 0, 0);
		try {
			if (!multipleMonitor.exist())
				multipleMonitor.insert();
		} catch (WaarpDatabaseException e1) {
			e1.printStackTrace();
		}

		// Configuration
		action = createTableH2 + DbConfiguration.table + "(";
		DbConfiguration.Columns[] ccolumns = DbConfiguration.Columns
				.values();
		for (int i = 0; i < ccolumns.length - 1; i++) {
			action += ccolumns[i].name() +
					DBType.getType(DbConfiguration.dbTypes[i]) + notNull +
					", ";
		}
		action += ccolumns[ccolumns.length - 1].name() +
				DBType.getType(DbConfiguration.dbTypes[ccolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		request = new DbRequest(session);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// HostConfiguration
		action = createTableH2 + DbHostConfiguration.table + "(";
		DbHostConfiguration.Columns[] chcolumns = DbHostConfiguration.Columns
				.values();
		for (int i = 0; i < chcolumns.length - 1; i++) {
			action += chcolumns[i].name() +
					DBType.getType(DbHostConfiguration.dbTypes[i]) + notNull +
					", ";
		}
		action += chcolumns[chcolumns.length - 1].name() +
				DBType.getType(DbHostConfiguration.dbTypes[chcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		request = new DbRequest(session);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			// XXX FIX no return;
		} finally {
			request.close();
		}
				
		// hosts
		action = createTableH2 + DbHostAuth.table + "(";
		DbHostAuth.Columns[] hcolumns = DbHostAuth.Columns.values();
		for (int i = 0; i < hcolumns.length - 1; i++) {
			action += hcolumns[i].name() +
					DBType.getType(DbHostAuth.dbTypes[i]) + notNull + ", ";
		}
		action += hcolumns[hcolumns.length - 1].name() +
				DBType.getType(DbHostAuth.dbTypes[hcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// rules
		action = createTableH2 + DbRule.table + "(";
		DbRule.Columns[] rcolumns = DbRule.Columns.values();
		for (int i = 0; i < rcolumns.length - 1; i++) {
			action += rcolumns[i].name() +
					DBType.getType(DbRule.dbTypes[i]) + ", ";
		}
		action += rcolumns[rcolumns.length - 1].name() +
				DBType.getType(DbRule.dbTypes[rcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// runner
		action = createTableH2 + DbTaskRunner.table + "(";
		DbTaskRunner.Columns[] acolumns = DbTaskRunner.Columns.values();
		for (int i = 0; i < acolumns.length; i++) {
			action += acolumns[i].name() +
					DBType.getType(DbTaskRunner.dbTypes[i]) + notNull + ", ";
		}
		// Several columns for primary key
		action += " CONSTRAINT runner_pk " + primaryKey + "(";
		for (int i = DbTaskRunner.NBPRKEY; i > 1; i--) {
			action += acolumns[acolumns.length - i].name() + ",";
		}
		action += acolumns[acolumns.length - 1].name() + "))";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}
		// Index Runner
		action = "CREATE INDEX IF NOT EXISTS IDX_RUNNER ON " + DbTaskRunner.table + "(";
]]>
</codefragment>
</duplication>
<duplication lines="107" tokens="505">
<file line="299" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="293" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
				request.query(command);
			} catch (WaarpDatabaseSqlException e) {
				e.printStackTrace();
				return false;
			} finally {
				request.close();
			}
		}
		return true;
	}
	
	/*
	 * (non-Javadoc)
	 * @see org.waarp.openr66.databaseold.model.DbModel#resetSequence()
	 */
	@Override
	public void resetSequence(DbSession session, long newvalue)
			throws WaarpDatabaseNoConnectionException {
		String action = "ALTER SEQUENCE " + DbTaskRunner.fieldseq +
				" RESTART WITH " + newvalue;
		DbRequest request = new DbRequest(session);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			return;
		} finally {
			request.close();
		}
		System.out.println(action);
	}

	/*
	 * (non-Javadoc)
	 * @see org.waarp.openr66.databaseold.model.DbModel#nextSequence()
	 */
	@Override
	public long nextSequence(DbSession dbSession)
			throws WaarpDatabaseNoConnectionException,
			WaarpDatabaseSqlException, WaarpDatabaseNoDataException {
		long result = DbConstant.ILLEGALVALUE;
		String action = "SELECT NEXTVAL('" + DbTaskRunner.fieldseq + "')";
		DbPreparedStatement preparedStatement = new DbPreparedStatement(
				dbSession);
		try {
			preparedStatement.createPrepareStatement(action);
			// Limit the search
			preparedStatement.executeQuery();
			if (preparedStatement.getNext()) {
				try {
					result = preparedStatement.getResultSet().getLong(1);
				} catch (SQLException e) {
					throw new WaarpDatabaseSqlException(e);
				}
				return result;
			} else {
				throw new WaarpDatabaseNoDataException(
						"No sequence found. Must be initialized first");
			}
		} finally {
			preparedStatement.realClose();
		}
	}

	public boolean needUpgradeDb(DbSession session, String version, boolean tryFix)
			throws WaarpDatabaseNoConnectionException {
		// Check if the database is up to date
		DbRequest request = null;
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_13.getVersion())) {
			try {
				request = new DbRequest(session);
				request.select("select "+DbHostConfiguration.Columns.HOSTID.name()+" from "+DbHostConfiguration.table+
						" where "+DbHostConfiguration.Columns.HOSTID+" = '"+Configuration.configuration.HOST_ID+"'");
				request.close();
				DbHostConfiguration.updateVersionDb(session, Configuration.configuration.HOST_ID, R66Versions.V2_4_13.getVersion());
			} catch (WaarpDatabaseSqlException e) {
				return ! upgradeDb(session, version);
			} finally {
				if (request != null) {
					request.close();
				}
			}
		}
		request = null;
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_17.getVersion())) {
			try {
				request = new DbRequest(session);
				request.select("select "+DbTaskRunner.Columns.TRANSFERINFO.name()+" from "+DbTaskRunner.table+
						" where "+DbTaskRunner.Columns.SPECIALID+" = "+DbConstant.ILLEGALVALUE);
				request.close();
				DbHostConfiguration.updateVersionDb(session, Configuration.configuration.HOST_ID, R66Versions.V2_4_17.getVersion());
			} catch (WaarpDatabaseSqlException e) {
				return ! upgradeDb(session, version);
			} finally {
				if (request != null) {
					request.close();
				}
			}
		}
		return false;
	}
	
	
}
]]>
</codefragment>
</duplication>
<duplication lines="62" tokens="353">
<file line="344" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="357" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelOracle.java"/>
<file line="338" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
		DbPreparedStatement preparedStatement = new DbPreparedStatement(
				dbSession);
		try {
			preparedStatement.createPrepareStatement(action);
			// Limit the search
			preparedStatement.executeQuery();
			if (preparedStatement.getNext()) {
				try {
					result = preparedStatement.getResultSet().getLong(1);
				} catch (SQLException e) {
					throw new WaarpDatabaseSqlException(e);
				}
				return result;
			} else {
				throw new WaarpDatabaseNoDataException(
						"No sequence found. Must be initialized first");
			}
		} finally {
			preparedStatement.realClose();
		}
	}

	public boolean needUpgradeDb(DbSession session, String version, boolean tryFix)
			throws WaarpDatabaseNoConnectionException {
		// Check if the database is up to date
		DbRequest request = null;
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_13.getVersion())) {
			try {
				request = new DbRequest(session);
				request.select("select "+DbHostConfiguration.Columns.HOSTID.name()+" from "+DbHostConfiguration.table+
						" where "+DbHostConfiguration.Columns.HOSTID+" = '"+Configuration.configuration.HOST_ID+"'");
				request.close();
				DbHostConfiguration.updateVersionDb(session, Configuration.configuration.HOST_ID, R66Versions.V2_4_13.getVersion());
			} catch (WaarpDatabaseSqlException e) {
				return ! upgradeDb(session, version);
			} finally {
				if (request != null) {
					request.close();
				}
			}
		}
		request = null;
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_17.getVersion())) {
			try {
				request = new DbRequest(session);
				request.select("select "+DbTaskRunner.Columns.TRANSFERINFO.name()+" from "+DbTaskRunner.table+
						" where "+DbTaskRunner.Columns.SPECIALID+" = "+DbConstant.ILLEGALVALUE);
				request.close();
				DbHostConfiguration.updateVersionDb(session, Configuration.configuration.HOST_ID, R66Versions.V2_4_17.getVersion());
			} catch (WaarpDatabaseSqlException e) {
				return ! upgradeDb(session, version);
			} finally {
				if (request != null) {
					request.close();
				}
			}
		}
		return false;
	}
	
	
}
]]>
</codefragment>
</duplication>
<duplication lines="46" tokens="306">
<file line="245" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="269" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMariadb.java"/>
<file line="269" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<codefragment>
<![CDATA[
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}
	}

	public boolean upgradeDb(DbSession session, String version) throws WaarpDatabaseNoConnectionException {
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_13.getVersion())) {
			System.out.println(version+" to "+R66Versions.V2_4_13.getVersion()+"? "+true);
			String createTableH2 = "CREATE TABLE IF NOT EXISTS ";
			String primaryKey = " PRIMARY KEY ";
			String notNull = " NOT NULL ";
	
			// HostConfiguration
			String action = createTableH2 + DbHostConfiguration.table + "(";
			DbHostConfiguration.Columns[] chcolumns = DbHostConfiguration.Columns
					.values();
			for (int i = 0; i < chcolumns.length - 1; i++) {
				action += chcolumns[i].name() +
						DBType.getType(DbHostConfiguration.dbTypes[i]) + notNull +
						", ";
			}
			action += chcolumns[chcolumns.length - 1].name() +
					DBType.getType(DbHostConfiguration.dbTypes[chcolumns.length - 1]) +
					primaryKey + ")";
			System.out.println(action);
			DbRequest request = new DbRequest(session);
			try {
				request.query(action);
			} catch (WaarpDatabaseSqlException e) {
				e.printStackTrace();
				return false;
			} finally {
				request.close();
			}
		}
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_17.getVersion())) {
			System.out.println(version+" to "+R66Versions.V2_4_17.getVersion()+"? "+true);
]]>
</codefragment>
</duplication>
<duplication lines="45" tokens="281">
<file line="388" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\http\adminssl\HttpSslHandler.java"/>
<file line="498" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\http\adminssl\HttpSslHandler.java"/>
<codefragment>
<![CDATA[
				DbPreparedStatement preparedStatement = null;
				try {
					preparedStatement =
							DbTaskRunner.getFilterPrepareStatement(dbSession, LIMITROW, false,
									startid, stopid, tstart, tstop, rule, req,
									pending, transfer, error, done, all);
					preparedStatement.executeQuery();
					StringBuilder builder = new StringBuilder();
					int i = 0;
					while (preparedStatement.getNext()) {
						try {
							i++;
							DbTaskRunner taskRunner = DbTaskRunner
									.getFromStatement(preparedStatement);
							long specid = taskRunner.getSpecialId();
							if (idstart == null || idstart > specid) {
								idstart = specid;
							}
							LocalChannelReference lcr =
									Configuration.configuration.getLocalTransaction().
											getFromRequest(taskRunner.getKey());
							builder.append(taskRunner.toSpecializedHtml(authentHttp, body,
									lcr != null ? "Active" : "NotActive"));
							if (i > LIMITROW) {
								break;
							}
						} catch (WaarpDatabaseException e) {
							// try to continue if possible
							logger.warn("An error occurs while accessing a Runner: {}",
									e.getMessage());
							continue;
						}
					}
					preparedStatement.realClose();
					body = builder.toString();
				} catch (WaarpDatabaseException e) {
					if (preparedStatement != null) {
						preparedStatement.realClose();
					}
					logger.warn("OpenR66 Web Error {}", e.getMessage());
				}
				head = resetOptionTransfer(head, startid == null ? (idstart != null ? idstart.toString() : "") : startid,
						stopid == null ? "" : stopid, start, stop,
						rule == null ? "" : rule, req == null ? "" : req,
						pending, transfer, error, done, all);
]]>
</codefragment>
</duplication>
<duplication lines="44" tokens="277">
<file line="362" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="413" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMariadb.java"/>
<file line="413" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="375" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelOracle.java"/>
<file line="356" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
			preparedStatement.realClose();
		}
	}

	public boolean needUpgradeDb(DbSession session, String version, boolean tryFix)
			throws WaarpDatabaseNoConnectionException {
		// Check if the database is up to date
		DbRequest request = null;
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_13.getVersion())) {
			try {
				request = new DbRequest(session);
				request.select("select "+DbHostConfiguration.Columns.HOSTID.name()+" from "+DbHostConfiguration.table+
						" where "+DbHostConfiguration.Columns.HOSTID+" = '"+Configuration.configuration.HOST_ID+"'");
				request.close();
				DbHostConfiguration.updateVersionDb(session, Configuration.configuration.HOST_ID, R66Versions.V2_4_13.getVersion());
			} catch (WaarpDatabaseSqlException e) {
				return ! upgradeDb(session, version);
			} finally {
				if (request != null) {
					request.close();
				}
			}
		}
		request = null;
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_17.getVersion())) {
			try {
				request = new DbRequest(session);
				request.select("select "+DbTaskRunner.Columns.TRANSFERINFO.name()+" from "+DbTaskRunner.table+
						" where "+DbTaskRunner.Columns.SPECIALID+" = "+DbConstant.ILLEGALVALUE);
				request.close();
				DbHostConfiguration.updateVersionDb(session, Configuration.configuration.HOST_ID, R66Versions.V2_4_17.getVersion());
			} catch (WaarpDatabaseSqlException e) {
				return ! upgradeDb(session, version);
			} finally {
				if (request != null) {
					request.close();
				}
			}
		}
		return false;
	}
	
	
}
]]>
</codefragment>
</duplication>
<duplication lines="48" tokens="274">
<file line="96" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\context\task\ExecMoveTask.java"/>
<file line="102" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\context\task\ExecOutputTask.java"/>
<codefragment>
<![CDATA[
				move(result.status, result.result, finalname);
				localExecClient.disconnect();
				return;
			} // else continue
		}
		String[] args = finalname.split(" ");
		File exec = new File(args[0]);
		if (exec.isAbsolute()) {
			if (!exec.canExecute()) {
				logger.error("Exec command is not executable: " + finalname);
				R66Result result = new R66Result(session, false,
						ErrorCode.CommandNotFound, session.getRunner());
				futureCompletion.setResult(result);
				futureCompletion.cancel();
				return;
			}
		}
		CommandLine commandLine = new CommandLine(args[0]);
		for (int i = 1; i < args.length; i++) {
			commandLine.addArgument(args[i]);
		}
		DefaultExecutor defaultExecutor = new DefaultExecutor();
		PipedInputStream inputStream = new PipedInputStream();
		PipedOutputStream outputStream = null;
		try {
			outputStream = new PipedOutputStream(inputStream);
		} catch (IOException e1) {
			try {
				inputStream.close();
			} catch (IOException e) {
			}
			logger.error("Exception: " + e1.getMessage() +
					" Exec in error with " + commandLine.toString(), e1);
			futureCompletion.setFailure(e1);
			return;
		}
		PumpStreamHandler pumpStreamHandler = new PumpStreamHandler(
				outputStream, null);
		defaultExecutor.setStreamHandler(pumpStreamHandler);
		int[] correctValues = {
				0, 1 };
		defaultExecutor.setExitValues(correctValues);
		ExecuteWatchdog watchdog = null;

		if (delay > 0) {
			watchdog = new ExecuteWatchdog(delay);
			defaultExecutor.setWatchdog(watchdog);
		}
]]>
</codefragment>
</duplication>
<duplication lines="19" tokens="270">
<file line="476" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbRule.java"/>
<file line="505" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbRule.java"/>
<codefragment>
<![CDATA[
	protected void setFromArray() throws WaarpDatabaseSqlException {
		ids = (String) allFields[Columns.HOSTIDS.ordinal()].getValue();
		mode = (Integer) allFields[Columns.MODETRANS.ordinal()].getValue();
		recvPath = (String) allFields[Columns.RECVPATH.ordinal()].getValue();
		sendPath = (String) allFields[Columns.SENDPATH.ordinal()].getValue();
		archivePath = (String) allFields[Columns.ARCHIVEPATH.ordinal()]
				.getValue();
		workPath = (String) allFields[Columns.WORKPATH.ordinal()].getValue();
		rpreTasks = (String) allFields[Columns.RPRETASKS.ordinal()].getValue();
		rpostTasks = (String) allFields[Columns.RPOSTTASKS.ordinal()].getValue();
		rerrorTasks = (String) allFields[Columns.RERRORTASKS.ordinal()]
				.getValue();
		spreTasks = (String) allFields[Columns.SPRETASKS.ordinal()].getValue();
		spostTasks = (String) allFields[Columns.SPOSTTASKS.ordinal()].getValue();
		serrorTasks = (String) allFields[Columns.SERRORTASKS.ordinal()]
				.getValue();
		updatedInfo = (Integer) allFields[Columns.UPDATEDINFO.ordinal()]
				.getValue();
		idRule = (String) allFields[Columns.IDRULE.ordinal()].getValue();
]]>
</codefragment>
</duplication>
<duplication lines="23" tokens="267">
<file line="1571" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\http\adminssl\HttpSslHandler.java"/>
<file line="1725" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\http\adminssl\HttpSslHandler.java"/>
<codefragment>
<![CDATA[
			String system = REQUEST.System.readFileUnique(this);
			StringBuilder builder = new StringBuilder(system);
			WaarpStringUtils.replace(builder, REPLACEMENT.XXXXBUSINESSXXX.toString(),
					config.getBusiness());
			WaarpStringUtils.replace(builder, REPLACEMENT.XXXXROLESXXX.toString(),
					config.getRoles());
			WaarpStringUtils.replace(builder, REPLACEMENT.XXXXALIASESXXX.toString(),
					config.getAliases());
			WaarpStringUtils.replace(builder, REPLACEMENT.XXXXOTHERXXX.toString(),
					config.getOthers());
			WaarpStringUtils.replace(builder, REPLACEMENT.XXXXSESSIONLIMITWXXX.toString(),
					Long.toString(Configuration.configuration.serverChannelWriteLimit));
			WaarpStringUtils.replace(builder, REPLACEMENT.XXXXSESSIONLIMITRXXX.toString(),
					Long.toString(Configuration.configuration.serverChannelReadLimit));
			WaarpStringUtils.replace(builder, REPLACEMENT.XXXXDELAYCOMMDXXX.toString(),
					Long.toString(Configuration.configuration.delayCommander));
			WaarpStringUtils.replace(builder, REPLACEMENT.XXXXDELAYRETRYXXX.toString(),
					Long.toString(Configuration.configuration.delayRetry));
			WaarpStringUtils.replace(builder, REPLACEMENT.XXXXCHANNELLIMITWXXX.toString(),
					Long.toString(Configuration.configuration.serverGlobalWriteLimit));
			WaarpStringUtils.replace(builder, REPLACEMENT.XXXXCHANNELLIMITRXXX.toString(),
					Long.toString(Configuration.configuration.serverGlobalReadLimit));
			WaarpStringUtils.replace(builder, "XXXBLOCKXXX", Configuration.configuration.isShutdown ? "checked" : "");
]]>
</codefragment>
</duplication>
<duplication lines="46" tokens="260">
<file line="1724" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<file line="1791" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<codefragment>
<![CDATA[
				session.newState(ENDTRANSFERR);
				try {
					session.setFinalizeTransfer(true, result);
				} catch (OpenR66RunnerErrorException e) {
					// TODO
					session.newState(ERROR);
					ErrorPacket error = null;
					if (localChannelReference.getFutureRequest().getResult() != null) {
						result = localChannelReference.getFutureRequest().getResult();
						error = new ErrorPacket(
							"Error while finalizing transfer: "+result.getMessage(),
							result.code.getCode(), ErrorPacket.FORWARDCLOSECODE);
					} else {
						error = new ErrorPacket(
								"Error while finalizing transfer",
								ErrorCode.FinalOp.getCode(), ErrorPacket.FORWARDCLOSECODE);
					}
					try {
						ChannelUtils.writeAbstractLocalPacket(localChannelReference, error, true);
					} catch (OpenR66ProtocolPacketException e1) {
					}
					session.setStatus(23);
					ChannelCloseTimer.closeFutureChannel(channel);
					return;
				} catch (OpenR66ProtocolSystemException e) {
					// TODO
					session.newState(ERROR);
					ErrorPacket error = null;
					if (localChannelReference.getFutureRequest().getResult() != null) {
						result = localChannelReference.getFutureRequest().getResult();
						error = new ErrorPacket(
							"Error while finalizing transfer: "+result.getMessage(),
							result.code.getCode(), ErrorPacket.FORWARDCLOSECODE);
					} else {
						error = new ErrorPacket(
								"Error while finalizing transfer",
								ErrorCode.FinalOp.getCode(), ErrorPacket.FORWARDCLOSECODE);
					}
					try {
						ChannelUtils.writeAbstractLocalPacket(localChannelReference, error, true);
					} catch (OpenR66ProtocolPacketException e1) {
					}
					session.setStatus(23);
					ChannelCloseTimer.closeFutureChannel(channel);
					return;
				}
]]>
</codefragment>
</duplication>
<duplication lines="34" tokens="241">
<file line="352" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\http\adminssl\HttpSslHandler.java"/>
<file line="462" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\http\adminssl\HttpSslHandler.java"/>
<codefragment>
<![CDATA[
			body0 = REQUEST.Listing.readBodyHeader();
			String parm = parms.get(0);
			if ("Filter".equalsIgnoreCase(parm)) {
				String startid = getTrimValue("startid");
				String stopid = getTrimValue("stopid");
				if (startid != null && stopid == null) {
					stopid = Long.MAX_VALUE+"";
				}
				if (stopid != null && startid == null) {
                   	startid = (DbConstant.ILLEGALVALUE+1)+"";
				}
				String start = getValue("start");
				String stop = getValue("stop");
				String rule = getTrimValue("rule");
				String req = getTrimValue("req");
				boolean pending, transfer, error, done, all;
				pending = params.containsKey("pending");
				transfer = params.containsKey("transfer");
				error = params.containsKey("error");
				done = params.containsKey("done");
				all = params.containsKey("all");
				if (pending && transfer && error && done) {
					all = true;
				} else if (!(pending || transfer || error || done)) {
					all = true;
				}
				Timestamp tstart = WaarpStringUtils.fixDate(start);
				if (tstart != null) {
					start = tstart.toString();
				}
				Timestamp tstop = WaarpStringUtils.fixDate(stop, tstart);
				if (tstop != null) {
					stop = tstop.toString();
				}
]]>
</codefragment>
</duplication>
<duplication lines="44" tokens="236">
<file line="2656" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<file line="2968" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<codefragment>
<![CDATA[
					}
				}
				// check if send is already on going
				if (session.getRunner() != null && session.getRunner().getRank() > 0) {
					// already started so not changing the filename
					// Success: No write back at all
					break;
				}
				// Pre execution was already done since this packet is only received once
				// the request is already validated by the receiver
				try {
					session.renameReceiverFile(newfilename);
				} catch (OpenR66RunnerErrorException e) {
					DbTaskRunner runner = session.getRunner();
					runner.saveStatus();
					runner.setErrorExecutionStatus(ErrorCode.FileNotFound);
					session.newState(ERROR);
					logger.error("File renaming in error {}", e.getMessage());
					ErrorPacket error = new ErrorPacket("File renaming in error: " + e
							.getMessage(), runner.getErrorInfo().getCode(),
							ErrorPacket.FORWARDCLOSECODE);
					try {
						ChannelUtils.writeAbstractLocalPacket(localChannelReference,
								error, true);
					} catch (OpenR66ProtocolPacketException e2) {
					}
					try {
						session.setFinalizeTransfer(false, new R66Result(e, session,
								true, runner.getErrorInfo(), runner));
					} catch (OpenR66RunnerErrorException e1) {
						localChannelReference.invalidateRequest(new R66Result(e, session,
								true, runner.getErrorInfo(), runner));
					} catch (OpenR66ProtocolSystemException e1) {
						localChannelReference.invalidateRequest(new R66Result(e, session,
								true, runner.getErrorInfo(), runner));
					}
					session.setStatus(97);
					ChannelCloseTimer.closeFutureChannel(channel);
					return;
				}
				// Success: No write back at all
				break;
			}
			case LocalPacketFactory.BANDWIDTHPACKET: {
]]>
</codefragment>
</duplication>
<duplication lines="49" tokens="233">
<file line="1864" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<file line="1950" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<codefragment>
<![CDATA[
	public static boolean setConfigurationServerShutdownFromXml(Configuration config,
			String filename) {
		Document document = null;
		// Open config file
		try {
			document = new SAXReader().read(filename);
		} catch (DocumentException e) {
			logger.error(Messages.getString("FileBasedConfiguration.CannotReadXml") + filename, e); //$NON-NLS-1$
			return false;
		}
		if (document == null) {
			logger.error(Messages.getString("FileBasedConfiguration.CannotReadXml") + filename); //$NON-NLS-1$
			return false;
		}
		configuration = XmlUtil.read(document, configServer);
		hashConfig = new XmlHash(configuration);
		// Now read the configuration
		loadLocale(config);
		if (!loadIdentity(config)) {
			logger.error("Cannot load Identity");
			return false;
		}
		if (!loadDatabase(config)) {
			logger.error("Cannot load Database configuration");
			return false;
		}
		if (!loadServerParam(config)) {
			logger.error("Cannot load Server Parameters");
			return false;
		}
		if (!loadDirectory(config)) {
			logger.error("Cannot load Directory configuration");
			return false;
		}
		if (!loadLimit(config, false)) {
			logger.error("Cannot load Limit configuration");
			return false;
		}
		if (config.useSSL) {
			if (!loadSsl(config)) {
				logger.error("Cannot load SSL configuration");
				return false;
			}
		}
		if (!loadNetworkServer(config)) {
			logger.error("Cannot load Network configuration");
			return false;
		}
		if (!DbConstant.admin.isConnected) {
]]>
</codefragment>
</duplication>
<duplication lines="40" tokens="207">
<file line="3661" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbTaskRunner.java"/>
<file line="3851" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbTaskRunner.java"/>
<codefragment>
<![CDATA[
		} catch (FileNotFoundException e) {
			logger.error("Cannot write XML file", e);
			throw new OpenR66ProtocolBusinessException("File not found");
		} catch (UnsupportedEncodingException e) {
			logger.error("Cannot write XML file", e);
			throw new OpenR66ProtocolBusinessException("Unsupported Encoding");
		} finally {
			if (xmlWriter != null) {
				try {
					xmlWriter.endDocument();
					xmlWriter.flush();
					xmlWriter.close();
				} catch (SAXException e) {
					try {
						outputStream.close();
					} catch (IOException e2) {
					}
					File file = new File(filename);
					file.delete();
					logger.error("Cannot write XML file", e);
					throw new OpenR66ProtocolBusinessException("Unsupported Encoding");
				} catch (IOException e) {
					try {
						outputStream.close();
					} catch (IOException e2) {
					}
					File file = new File(filename);
					file.delete();
					logger.error("Cannot write XML file", e);
					throw new OpenR66ProtocolBusinessException("Unsupported Encoding");
				}
			} else if (outputStream != null) {
				try {
					outputStream.close();
				} catch (IOException e) {
				}
				File file = new File(filename);
				file.delete();
			}
		}
]]>
</codefragment>
</duplication>
<duplication lines="29" tokens="207">
<file line="263" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="259" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
			String primaryKey = " PRIMARY KEY ";
			String notNull = " NOT NULL ";
	
			// HostConfiguration
			String action = createTableH2 + DbHostConfiguration.table + "(";
			DbHostConfiguration.Columns[] chcolumns = DbHostConfiguration.Columns
					.values();
			for (int i = 0; i < chcolumns.length - 1; i++) {
				action += chcolumns[i].name() +
						DBType.getType(DbHostConfiguration.dbTypes[i]) + notNull +
						", ";
			}
			action += chcolumns[chcolumns.length - 1].name() +
					DBType.getType(DbHostConfiguration.dbTypes[chcolumns.length - 1]) +
					primaryKey + ")";
			System.out.println(action);
			DbRequest request = new DbRequest(session);
			try {
				request.query(action);
			} catch (WaarpDatabaseSqlException e) {
				e.printStackTrace();
				return false;
			} finally {
				request.close();
			}
		}
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_17.getVersion())) {
			System.out.println(version+" to "+R66Versions.V2_4_17.getVersion()+"? "+true);
			String command = "ALTER TABLE "+DbTaskRunner.table+" ADD COLUMN IF NOT EXISTS "+
]]>
</codefragment>
</duplication>
<duplication lines="49" tokens="205">
<file line="205" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\context\task\ExecMoveTask.java"/>
<file line="201" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\context\task\ExecOutputTask.java"/>
<codefragment>
<![CDATA[
				futureCompletion.setFailure(e);
				return;
			}
		} catch (IOException e) {
			try {
				outputStream.close();
			} catch (IOException e1) {
			}
			thread.interrupt();
			try {
				inputStream.close();
			} catch (IOException e1) {
			}
			pumpStreamHandler.stop();
			logger.error("IOException: " + e.getMessage() +
					" . Exec in error with " + commandLine.toString());
			futureCompletion.setFailure(e);
			return;
		}
		try {
			outputStream.flush();
		} catch (IOException e) {
		}
		try {
			outputStream.close();
		} catch (IOException e) {
		}
		pumpStreamHandler.stop();
		try {
			if (delay > 0) {
				thread.join(delay);
			} else {
				thread.join();
			}
		} catch (InterruptedException e) {
			Thread.currentThread().interrupt();
		}
		try {
			inputStream.close();
		} catch (IOException e1) {
		}
		String newname = null;
		if (defaultExecutor.isFailure(status) && watchdog != null &&
				watchdog.killedProcess()) {
			// kill by the watchdoc (time out)
			status = -1;
			newname = "TimeOut";
		} else {
			newname = lastLineReader.lastLine;
]]>
</codefragment>
</duplication>
<duplication lines="28" tokens="198">
<file line="287" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMariadb.java"/>
<file line="287" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="259" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
			String primaryKey = " PRIMARY KEY ";
			String notNull = " NOT NULL ";
	
			// HostConfiguration
			String action = createTableH2 + DbHostConfiguration.table + "(";
			DbHostConfiguration.Columns[] chcolumns = DbHostConfiguration.Columns
					.values();
			for (int i = 0; i < chcolumns.length - 1; i++) {
				action += chcolumns[i].name() +
						DBType.getType(DbHostConfiguration.dbTypes[i]) + notNull +
						", ";
			}
			action += chcolumns[chcolumns.length - 1].name() +
					DBType.getType(DbHostConfiguration.dbTypes[chcolumns.length - 1]) +
					primaryKey + ")";
			System.out.println(action);
			DbRequest request = new DbRequest(session);
			try {
				request.query(action);
			} catch (WaarpDatabaseSqlException e) {
				e.printStackTrace();
				return false;
			} finally {
				request.close();
			}
		}
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_17.getVersion())) {
			System.out.println(version+" to "+R66Versions.V2_4_17.getVersion()+"? "+true);
]]>
</codefragment>
</duplication>
<duplication lines="39" tokens="197">
<file line="1743" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<file line="1795" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<codefragment>
<![CDATA[
	public static boolean setConfigurationInitDatabase(Configuration config, String filename) {
		Document document = null;
		// Open config file
		try {
			document = new SAXReader().read(filename);
		} catch (DocumentException e) {
			logger.error(Messages.getString("FileBasedConfiguration.CannotReadXml") + filename, e); //$NON-NLS-1$
			return false;
		}
		if (document == null) {
			logger.error(Messages.getString("FileBasedConfiguration.CannotReadXml") + filename); //$NON-NLS-1$
			return false;
		}
		configuration = XmlUtil.read(document, configServer);
		hashConfig = new XmlHash(configuration);
		loadLocale(config);
		if (!loadIdentity(config)) {
			logger.error("Cannot load Identity");
			return false;
		}
		if (!loadDatabase(config)) {
			logger.error("Cannot load Database configuration");
			return false;
		}
		if (!loadDirectory(config)) {
			logger.error("Cannot load Directory configuration");
			return false;
		}
		if (!loadLimit(config, false)) {
			logger.error("Cannot load Limit configuration");
			return false;
		}
		if (!DbConstant.admin.isConnected) {
			// if no database, must load authentication from file
			if (!loadAuthentication(config)) {
				logger.error("Cannot load Authentication configuration");
				return false;
			}
		}
]]>
</codefragment>
</duplication>
<duplication lines="15" tokens="173">
<file line="188" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\client\DirectTransfer.java"/>
<file line="213" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\client\MultipleDirectTransfer.java"/>
<codefragment>
<![CDATA[
					outputFormat.setValue(FIELDS.remote.name(), rhost);
					logger.error(outputFormat.loggerOut(), future.getCause());
					outputFormat.setValue(FIELDS.error.name(), future.getCause().getMessage());
					outputFormat.sysout();
					networkTransaction.closeAll();
					System.exit(ErrorCode.Unknown.ordinal());
				}
				if (result.runner.getErrorInfo() == ErrorCode.Warning) {
					outputFormat.setValue(FIELDS.status.name(), 1);
					outputFormat.setValue(FIELDS.statusTxt.name(), Messages.getString("Transfer.Status")+Messages.getString("RequestInformation.Warned")); //$NON-NLS-1$
				} else {
					outputFormat.setValue(FIELDS.status.name(), 2);
					outputFormat.setValue(FIELDS.statusTxt.name(), Messages.getString("Transfer.Status")+Messages.getString("RequestInformation.Failure")); //$NON-NLS-1$
				}
				outputFormat.setValue(FIELDS.remote.name(), rhost);
]]>
</codefragment>
</duplication>
<duplication lines="24" tokens="170">
<file line="163" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\server\LogExport.java"/>
<file line="304" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\server\LogExtendedExport.java"/>
<codefragment>
<![CDATA[
	protected static boolean getParams(String[] args) {
		if (args.length < 1) {
			logger.error(_INFO_ARGS);
			return false;
		}
		if (!FileBasedConfiguration
				.setClientConfigurationFromXml(Configuration.configuration, args[0])) {
			logger.error(_INFO_ARGS);
			return false;
		}
		String ssstart = null;
		String ssstop = null;
		for (int i = 1; i < args.length; i++) {
			if (args[i].equalsIgnoreCase("-purge")) {
				spurgeLog = true;
			} else if (args[i].equalsIgnoreCase("-clean")) {
				sclean = true;
			} else if (args[i].equalsIgnoreCase("-start")) {
				i++;
				ssstart = args[i];
			} else if (args[i].equalsIgnoreCase("-stop")) {
				i++;
				ssstop = args[i];
			} else if (args[i].equalsIgnoreCase("-host")) {
]]>
</codefragment>
</duplication>
<duplication lines="21" tokens="168">
<file line="1014" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\http\adminssl\HttpSslHandler.java"/>
<file line="1066" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\http\adminssl\HttpSslHandler.java"/>
<codefragment>
<![CDATA[
			} else if ("TestConn".equalsIgnoreCase(parm)) {
				String host = getTrimValue("host");
				String addr = getTrimValue("address");
				String port = getTrimValue("port");
				String key = getTrimValue("hostkey");
				boolean ssl, admin, isclient;
				ssl = params.containsKey("ssl");
				admin = params.containsKey("admin");
				isclient = params.containsKey("isclient");
				head = resetOptionHosts(head, host, addr, ssl);
                int iport;
				try {
					iport = Integer.parseInt(port);
				} catch (NumberFormatException e1) {
					body0 = body1 = body = "";
                    body = Messages.getString("HttpSslHandler.17")+e1.getMessage()+"</b></center></p>"; //$NON-NLS-1$
                    head = resetOptionHosts(head, "", "", false);
                    return head+body0+body+body1+end;
				}
				DbHostAuth dbhost = new DbHostAuth(dbSession, host, addr, iport,
						ssl, key.getBytes(), admin, isclient);
]]>
</codefragment>
</duplication>
<duplication lines="26" tokens="164">
<file line="1333" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<file line="1358" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<codefragment>
<![CDATA[
		} else if ((!packet.getFilename().equals(runner.getOriginalFilename())) 
				&& runner.isSender() && runner.isInTransfer()
				&& runner.getRank() == 0 && (!packet.isToValidate())) {
			// File was modify at the very beginning (using wildcards)
			// and the remote host has already received the request packet
			// => Informs the receiver of the new name
			logger.debug("Will send a modification of filename due to wildcard: " +
					runner.getFilename());
			session.newState(VALID);
			if (localChannelReference.getPartner().useJson()) {
				RequestJsonPacket request = new RequestJsonPacket();
				request.setComment("Change Filename by Wildcard on sender");
				request.setFilename(runner.getFilename());
				request.setFilesize(packet.getOriginalSize());
				JsonCommandPacket validPacket = new JsonCommandPacket(request,
						LocalPacketFactory.REQUESTPACKET);
				ChannelUtils.writeAbstractLocalPacket(localChannelReference,
						validPacket, true);
			} else {
				ValidPacket validPacket = new ValidPacket("Change Filename by Wildcard on sender",
					runner.getFilename()+PartnerConfiguration.BAR_SEPARATOR_FIELD+packet.getOriginalSize(), 
					LocalPacketFactory.REQUESTPACKET);
				ChannelUtils.writeAbstractLocalPacket(localChannelReference,
					validPacket, true);
			}
		} else if (runner.isSelfRequest() && runner.isSender() && runner.isInTransfer()
]]>
</codefragment>
</duplication>
<duplication lines="42" tokens="163">
<file line="392" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbConfiguration.java"/>
<file line="593" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbHostConfiguration.java"/>
<codefragment>
<![CDATA[
		DbConfiguration dbConfiguration = new DbConfiguration(preparedStatement.getDbSession());
		dbConfiguration.getValues(preparedStatement, dbConfiguration.allFields);
		dbConfiguration.setFromArray();
		dbConfiguration.isSaved = true;
		return dbConfiguration;
	}

	/**
	 * 
	 * @return the DbPreparedStatement for getting Updated Object
	 * @throws WaarpDatabaseNoConnectionException
	 * @throws WaarpDatabaseSqlException
	 */
	public static DbPreparedStatement getUpdatedPrepareStament(DbSession session)
			throws WaarpDatabaseNoConnectionException, WaarpDatabaseSqlException {
		String request = "SELECT " + selectAllFields;
		request += " FROM " + table +
				" WHERE " + Columns.UPDATEDINFO.name() + " = " +
				AbstractDbData.UpdatedInfo.TOSUBMIT.ordinal() +
				" AND " + Columns.HOSTID.name() + " = '" + Configuration.configuration.HOST_ID
				+ "'";
		DbPreparedStatement prep = new DbPreparedStatement(session, request);
		return prep;
	}

	/*
	 * (non-Javadoc)
	 * @see org.waarp.openr66.databaseold.data.AbstractDbData#changeUpdatedInfo(UpdatedInfo)
	 */
	@Override
	public void changeUpdatedInfo(UpdatedInfo info) {
		if (updatedInfo != info.ordinal()) {
			updatedInfo = info.ordinal();
			allFields[Columns.UPDATEDINFO.ordinal()].setValue(updatedInfo);
			isSaved = false;
		}
	}

	/**
	 * Update configuration according to new value of limits
	 */
	public void updateConfiguration() {
]]>
</codefragment>
</duplication>
<duplication lines="25" tokens="162">
<file line="246" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\server\ConfigExport.java"/>
<file line="375" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\server\ConfigImport.java"/>
<codefragment>
<![CDATA[
					logger.error("COnfigExport in     FAILURE since Host is not found: "+stohost, e);
					networkTransaction.closeAll();
					System.exit(10);
				}
			} else {
				stohost = Configuration.configuration.HOST_SSLID;
			}
			transaction.run();
			future.awaitUninterruptibly();
			long time2 = System.currentTimeMillis();
			long delay = time2 - time1;
			R66Result result = future.getResult();
			if (future.isSuccess()) {
				boolean useJson = PartnerConfiguration.useJson(stohost);
				logger.debug("UseJson: "+useJson);
				String message = null;
				if (useJson) {
					message = (result.other != null ? ((JsonCommandPacket) result.other).getRequest() :
							"no file");
				} else {
					message = (result.other != null ? ((ValidPacket) result.other).getSheader() :
							"no file");
				}
				if (result.code == ErrorCode.Warning) {
					logger.warn("WARNED on files:     " +
]]>
</codefragment>
</duplication>
<duplication lines="25" tokens="155">
<file line="653" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbHostConfiguration.java"/>
<file line="749" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbHostConfiguration.java"/>
<codefragment>
<![CDATA[
	private boolean updateSet(String source, String path, HashSet<String> set) {
		if (source != null && ! source.isEmpty()) {
			Document document = null;
			StringReader reader = null;
			if (source != null && ! source.isEmpty()) {
				try {
					reader = new StringReader(source);
					document = new SAXReader().read(reader);
				} catch (DocumentException e) {
					logger.error("Unable to read the XML Config "+path+" string: " + source, e);
					if (reader != null) {
						reader.close();
					}
					return false;
				}
				if (document == null) {
					logger.error("Unable to read the XML Config "+path+" string: " + source);
					if (reader != null) {
						reader.close();
					}
					return false;
				}
				@SuppressWarnings("unchecked")
				List<Element> list = document.selectNodes(path);
				for (Element element : list) {
]]>
</codefragment>
</duplication>
<duplication lines="21" tokens="154">
<file line="1645" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbTaskRunner.java"/>
<file line="1685" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbTaskRunner.java"/>
<codefragment>
<![CDATA[
			DbSession session, boolean in)
			throws WaarpDatabaseNoConnectionException, WaarpDatabaseSqlException {
		String request = "SELECT COUNT(" + Columns.SPECIALID.name() + ") FROM " + table;
		String requesterd;
		String from = Configuration.configuration.HOST_ID;
		String sfrom = Configuration.configuration.HOST_SSLID;
		if (in) {
			requesterd = Columns.REQUESTED.name();
		} else {
			requesterd = Columns.REQUESTER.name();
		}
		if (from != null & sfrom != null) {
			request += " WHERE ((" + requesterd + " = '" +
					from + "' OR " + requesterd + " = '" + sfrom + "') ";
		} else if (from != null) {
			request += " WHERE (" + requesterd + " = '" + from + "' ";
		} else {
			request += " WHERE (" + requesterd + " = '" + sfrom + "' ";
		}
		request += " AND " + getLimitWhereCondition() + ") ";
		request += " AND " + Columns.STARTTRANS.name() + " >= ? ";
]]>
</codefragment>
</duplication>
<duplication lines="22" tokens="150">
<file line="139" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="142" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMariadb.java"/>
<file line="142" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="146" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelOracle.java"/>
<file line="135" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
		System.out.println(action);
		request = new DbRequest(session);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			// XXX FIX no return;
		} finally {
			request.close();
		}
				
		// hosts
		action = createTableH2 + DbHostAuth.table + "(";
		DbHostAuth.Columns[] hcolumns = DbHostAuth.Columns.values();
		for (int i = 0; i < hcolumns.length - 1; i++) {
			action += hcolumns[i].name() +
					DBType.getType(DbHostAuth.dbTypes[i]) + notNull + ", ";
		}
		action += hcolumns[hcolumns.length - 1].name() +
				DBType.getType(DbHostAuth.dbTypes[hcolumns.length - 1]) +
]]>
</codefragment>
</duplication>
<duplication lines="34" tokens="144">
<file line="490" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\context\filesystem\R66File.java"/>
<file line="554" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\context\filesystem\R66File.java"/>
<codefragment>
<![CDATA[
			File newFile = getFileFromPath(path);
			if (newFile.getParentFile().canWrite()) {
				if (!file.renameTo(newFile)) {
					FileOutputStream fileOutputStream = null;
					try {
						try {
							fileOutputStream = new FileOutputStream(newFile);
						} catch (FileNotFoundException e) {
							logger
									.warn("Cannot find file: " + newFile.getName(),
											e);
							return false;
						}
						FileChannel fileChannelOut = fileOutputStream.getChannel();
						if (get(fileChannelOut)) {
							delete();
						} else {
							try {
								fileChannelOut.close();
							} catch (IOException e) {
							}
							logger.error("Cannot write file: {}", newFile);
							return false;
						}
					} finally {
						if (fileOutputStream != null) {
							try {
								fileOutputStream.close();
							} catch (IOException e) {
							}
						}
					}
				}
				currentFile = getRelativePath(newFile);
]]>
</codefragment>
</duplication>
<duplication lines="26" tokens="143">
<file line="125" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\server\LogExport.java"/>
<file line="191" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\server\LogExtendedExport.java"/>
<codefragment>
<![CDATA[
				.createConnectionWithRetry(socketAddress, isSSL, future);
		socketAddress = null;
		if (localChannelReference == null) {
			host = null;
			logger.error("Cannot Connect");
			future.setResult(new R66Result(
					new OpenR66ProtocolNoConnectionException("Cannot connect to server"),
					null, true, ErrorCode.Internal, null));
			future.setFailure(future.getResult().exception);
			return;
		}
		localChannelReference.sessionNewState(R66FiniteDualStates.VALIDOTHER);
		try {
			ChannelUtils.writeAbstractLocalPacket(localChannelReference, valid, false);
		} catch (OpenR66ProtocolPacketException e) {
			logger.error("Bad Protocol", e);
			Channels.close(localChannelReference.getLocalChannel());
			localChannelReference = null;
			host = null;
			valid = null;
			future.setResult(new R66Result(e, null, true,
					ErrorCode.TransferError, null));
			future.setFailure(e);
			return;
		}
		host = null;
]]>
</codefragment>
</duplication>
<duplication lines="25" tokens="136">
<file line="228" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelOracle.java"/>
<file line="216" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
		} finally {
			request.close();
		}
		// Index Runner
		action = "CREATE INDEX IDX_RUNNER ON " + DbTaskRunner.table + "(";
		DbTaskRunner.Columns[] icolumns = DbTaskRunner.indexes;
		for (int i = 0; i < icolumns.length - 1; i++) {
			action += icolumns[i].name() + ", ";
		}
		action += icolumns[icolumns.length - 1].name() + ")";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// cptrunner
		action = "CREATE SEQUENCE " + DbTaskRunner.fieldseq +
				" MINVALUE " + (DbConstant.ILLEGALVALUE + 1) +
]]>
</codefragment>
</duplication>
<duplication lines="12" tokens="136">
<file line="705" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\http\adminssl\HttpSslHandler.java"/>
<file line="746" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\http\adminssl\HttpSslHandler.java"/>
<codefragment>
<![CDATA[
					body = REQUEST.CancelRestart.readBody();
					body = taskRunner.toSpecializedHtml(authentHttp, body,
							lcr != null ? "Active" : "NotActive");
					String tstart = taskRunner.getStart().toString();
					tstart = tstart.substring(0, tstart.length());
					String tstop = taskRunner.getStop().toString();
					tstop = tstop.substring(0, tstop.length());
					head = resetOptionTransfer(head, (taskRunner.getSpecialId() - 1) + "",
							(taskRunner.getSpecialId() + 1) + "", tstart, tstop,
							taskRunner.getRuleId(), taskRunner.getRequested(),
							false, false, false, false, true);
				}
]]>
</codefragment>
</duplication>
<duplication lines="22" tokens="135">
<file line="96" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\context\task\ExecMoveTask.java"/>
<file line="102" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\context\task\ExecOutputTask.java"/>
<file line="83" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\context\task\ExecTask.java"/>
<codefragment>
<![CDATA[
				move(result.status, result.result, finalname);
				localExecClient.disconnect();
				return;
			} // else continue
		}
		String[] args = finalname.split(" ");
		File exec = new File(args[0]);
		if (exec.isAbsolute()) {
			if (!exec.canExecute()) {
				logger.error("Exec command is not executable: " + finalname);
				R66Result result = new R66Result(session, false,
						ErrorCode.CommandNotFound, session.getRunner());
				futureCompletion.setResult(result);
				futureCompletion.cancel();
				return;
			}
		}
		CommandLine commandLine = new CommandLine(args[0]);
		for (int i = 1; i < args.length; i++) {
			commandLine.addArgument(args[i]);
		}
		DefaultExecutor defaultExecutor = new DefaultExecutor();
]]>
</codefragment>
</duplication>
<duplication lines="21" tokens="134">
<file line="2737" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<file line="3074" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<codefragment>
<![CDATA[
				long rsl = (Long.parseLong(splitsession[1]) / 10) * 10;
				if (wgl < 0) {
					wgl = Configuration.configuration.serverGlobalWriteLimit;
				}
				if (rgl < 0) {
					rgl = Configuration.configuration.serverGlobalReadLimit;
				}
				if (wsl < 0) {
					wsl = Configuration.configuration.serverChannelWriteLimit;
				}
				if (rsl < 0) {
					rsl = Configuration.configuration.serverChannelReadLimit;
				}
				if (Configuration.configuration.r66Mib != null) {
					Configuration.configuration.r66Mib.notifyWarning(
							"Change Bandwidth Limit Order received: Global " +
									wgl + ":" + rgl + " (W:R) Local " + wsl + ":" + rsl + " (W:R)",
							session.getAuth().getUser());
				}
				Configuration.configuration.changeNetworkLimit(wgl, rgl, wsl, rsl,
						Configuration.configuration.delayLimit);
]]>
</codefragment>
</duplication>
<duplication lines="25" tokens="133">
<file line="1743" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<file line="1795" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<file line="1864" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<file line="1950" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<codefragment>
<![CDATA[
	public static boolean setConfigurationInitDatabase(Configuration config, String filename) {
		Document document = null;
		// Open config file
		try {
			document = new SAXReader().read(filename);
		} catch (DocumentException e) {
			logger.error(Messages.getString("FileBasedConfiguration.CannotReadXml") + filename, e); //$NON-NLS-1$
			return false;
		}
		if (document == null) {
			logger.error(Messages.getString("FileBasedConfiguration.CannotReadXml") + filename); //$NON-NLS-1$
			return false;
		}
		configuration = XmlUtil.read(document, configServer);
		hashConfig = new XmlHash(configuration);
		loadLocale(config);
		if (!loadIdentity(config)) {
			logger.error("Cannot load Identity");
			return false;
		}
		if (!loadDatabase(config)) {
			logger.error("Cannot load Database configuration");
			return false;
		}
		if (!loadDirectory(config)) {
]]>
</codefragment>
</duplication>
<duplication lines="14" tokens="133">
<file line="133" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelOracle.java"/>
<file line="276" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelOracle.java"/>
<codefragment>
<![CDATA[
		action = createTableH2 + DbHostConfiguration.table + "(";
		DbHostConfiguration.Columns[] chcolumns = DbHostConfiguration.Columns
				.values();
		for (int i = 0; i < chcolumns.length - 1; i++) {
			action += chcolumns[i].name() +
					DBType.getType(DbHostConfiguration.dbTypes[i]) + notNull +
					", ";
		}
		action += chcolumns[chcolumns.length - 1].name() +
				DBType.getType(DbHostConfiguration.dbTypes[chcolumns.length - 1]) +
				notNull + ",";
		action += constraint + " hostconf_pk " + primaryKey + "("
				+ chcolumns[chcolumns.length - 1].name() + "))";
		System.out.println(action);
]]>
</codefragment>
</duplication>
<duplication lines="28" tokens="127">
<file line="1909" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<file line="1998" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<codefragment>
<![CDATA[
			logger.error("Cannot load Network configuration");
			return false;
		}
		if (!DbConstant.admin.isConnected) {
			// if no database, must load authentication from file
			if (!loadAuthentication(config)) {
				logger.error("Cannot load Authentication configuration");
				return false;
			}
		}
		config.HOST_AUTH = R66Auth.getServerAuth(
				DbConstant.admin.session, config.HOST_ID);
		if (config.HOST_AUTH == null &&
				config.useNOSSL) {
			logger.error("Cannot find Authentication for current host");
			return false;
		}
		if (config.HOST_SSLID != null) {
			config.HOST_SSLAUTH = R66Auth.getServerAuth(
					DbConstant.admin.session,
					config.HOST_SSLID);
			if (config.HOST_SSLAUTH == null &&
					config.useSSL) {
				logger.error("Cannot find SSL Authentication for current host");
				return false;
			}
		}
		loadBusinessWhiteList(config);
]]>
</codefragment>
</duplication>
<duplication lines="31" tokens="127">
<file line="782" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbTaskRunner.java"/>
<file line="824" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbTaskRunner.java"/>
<codefragment>
<![CDATA[
	public void insert() throws WaarpDatabaseException {
		if (isSaved) {
			return;
		}
		boolean shallIgnore = shallIgnoreSave();
		if (dbSession == null || shallIgnore) {
			if (specialId == DbConstant.ILLEGALVALUE) {
				// New SpecialId is not possible with No Database Model
				createNoDbSpecialId();
			}
			isSaved = true;
			if (Configuration.configuration.saveTaskRunnerWithNoDb) {
				try {
					setToArray();
					this.writeXmlWorkNoDb();
				} catch (OpenR66ProtocolBusinessException e) {
					// Ignore
				}
			}
			if (this.updatedInfo == UpdatedInfo.TOSUBMIT.ordinal()) {
				addNoDb();
			}
			if (shallIgnore) {
				dbR66TaskHashMap.put(specialId, this);
			}
			return;
		}
		// First need to find a new id if id is not ok
		if (specialId == DbConstant.ILLEGALVALUE) {
			specialId = DbModelFactory.dbModel.nextSequence(dbSession);
			logger.debug("Try Insert create a new Id from sequence: " +
]]>
</codefragment>
</duplication>
<duplication lines="27" tokens="123">
<file line="1824" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<file line="1909" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<file line="1998" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<codefragment>
<![CDATA[
			logger.error("Cannot load Limit configuration");
			return false;
		}
		if (!DbConstant.admin.isConnected) {
			// if no database, must load authentication from file
			if (!loadAuthentication(config)) {
				logger.error("Cannot load Authentication configuration");
				return false;
			}
		}
		config.HOST_AUTH = R66Auth.getServerAuth(
				DbConstant.admin.session, config.HOST_ID);
		if (config.HOST_AUTH == null &&
				config.useNOSSL) {
			logger.error("Cannot find Authentication for current host");
			return false;
		}
		if (config.HOST_SSLID != null) {
			config.HOST_SSLAUTH = R66Auth.getServerAuth(
					DbConstant.admin.session,
					config.HOST_SSLID);
			if (config.HOST_SSLAUTH == null &&
					config.useSSL) {
				logger.error("Cannot find SSL Authentication for current host");
				return false;
			}
		}
]]>
</codefragment>
</duplication>
<duplication lines="37" tokens="123">
<file line="2760" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<file line="3014" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<codefragment>
<![CDATA[
				ValidPacket valid = new ValidPacket("Bandwidth changed", result.code.getCode(),
						LocalPacketFactory.REQUESTUSERPACKET);
				localChannelReference.validateRequest(result);
				try {
					ChannelUtils.writeAbstractLocalPacket(localChannelReference,
							valid, true);
				} catch (OpenR66ProtocolPacketException e) {
				}
				Channels.close(channel);
				break;
			}
			case LocalPacketFactory.TESTPACKET: {
				session.newState(VALIDOTHER);
				logger.info("Valid TEST MESSAGE: " + packet.toString());
				R66Result resulttest = new R66Result(session, true,
						ErrorCode.CompleteOk, null);
				resulttest.other = packet;
				localChannelReference.validateRequest(resulttest);
				Channels.close(channel);
				break;
			}
			default:
				logger.info("Validation is ignored: " + packet.getTypeValid());
		}
	}

	/**
	 * Receive a json request
	 * 
	 * @param channel
	 * @param packet
	 * @throws OpenR66ProtocolNotAuthenticatedException
	 * @throws OpenR66RunnerErrorException
	 * @throws OpenR66ProtocolSystemException
	 * @throws OpenR66ProtocolBusinessException
	 */
	private void jsonCommand(Channel channel, JsonCommandPacket packet)
]]>
</codefragment>
</duplication>
<duplication lines="10" tokens="121">
<file line="159" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\client\DirectTransfer.java"/>
<file line="183" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\client\MultipleDirectTransfer.java"/>
<codefragment>
<![CDATA[
			OutputFormat outputFormat = new OutputFormat(DirectTransfer.class.getSimpleName(), args);
			if (future.isSuccess()) {
				if (result.runner.getErrorInfo() == ErrorCode.Warning) {
					outputFormat.setValue(FIELDS.status.name(), 1);
					outputFormat.setValue(FIELDS.statusTxt.name(), Messages.getString("Transfer.Status")+Messages.getString("RequestInformation.Warned")); //$NON-NLS-1$
				} else {
					outputFormat.setValue(FIELDS.status.name(), 0);
					outputFormat.setValue(FIELDS.statusTxt.name(), Messages.getString("Transfer.Status")+Messages.getString("RequestInformation.Success")); //$NON-NLS-1$
				}
				outputFormat.setValue(FIELDS.remote.name(), rhost);
]]>
</codefragment>
</duplication>
<duplication lines="31" tokens="121">
<file line="223" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMariadb.java"/>
<file line="223" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="228" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelOracle.java"/>
<codefragment>
<![CDATA[
		} finally {
			request.close();
		}
		// Index Runner
		action = "CREATE INDEX IDX_RUNNER ON " + DbTaskRunner.table + "(";
		DbTaskRunner.Columns[] icolumns = DbTaskRunner.indexes;
		for (int i = 0; i < icolumns.length - 1; i++) {
			action += icolumns[i].name() + ", ";
		}
		action += icolumns[icolumns.length - 1].name() + ")";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// cptrunner
		/*
		 * # Table to handle any number of sequences: CREATE TABLE Sequences ( name VARCHAR(22) NOT
		 * NULL, seq INT UNSIGNED NOT NULL, # (or BIGINT) PRIMARY KEY name ); # Create a Sequence:
		 * INSERT INTO Sequences (name, seq) VALUES (?, 0); # Drop a Sequence: DELETE FROM Sequences
		 * WHERE name = ?; # Get a sequence number: UPDATE Sequences SET seq = LAST_INSERT_ID(seq +
		 * 1) WHERE name = ?; $seq = $db->LastInsertId();
		 */
		action = "CREATE TABLE Sequences (name VARCHAR(22) NOT NULL PRIMARY KEY," +
]]>
</codefragment>
</duplication>
<duplication lines="22" tokens="121">
<file line="1727" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<file line="1748" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<file line="1794" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<file line="1815" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<codefragment>
<![CDATA[
				} catch (OpenR66RunnerErrorException e) {
					// TODO
					session.newState(ERROR);
					ErrorPacket error = null;
					if (localChannelReference.getFutureRequest().getResult() != null) {
						result = localChannelReference.getFutureRequest().getResult();
						error = new ErrorPacket(
							"Error while finalizing transfer: "+result.getMessage(),
							result.code.getCode(), ErrorPacket.FORWARDCLOSECODE);
					} else {
						error = new ErrorPacket(
								"Error while finalizing transfer",
								ErrorCode.FinalOp.getCode(), ErrorPacket.FORWARDCLOSECODE);
					}
					try {
						ChannelUtils.writeAbstractLocalPacket(localChannelReference, error, true);
					} catch (OpenR66ProtocolPacketException e1) {
					}
					session.setStatus(23);
					ChannelCloseTimer.closeFutureChannel(channel);
					return;
				} catch (OpenR66ProtocolSystemException e) {
]]>
</codefragment>
</duplication>
<duplication lines="24" tokens="120">
<file line="363" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\commander\Commander.java"/>
<file line="481" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\commander\Commander.java"/>
<codefragment>
<![CDATA[
					hostAuth = null;
				}
			} catch (WaarpDatabaseNoConnectionException e) {
				try {
					DbModelFactory.dbModel.validConnection(DbConstant.admin.session);
				} catch (WaarpDatabaseNoConnectionException e1) {
				}
				logger.error("Database No Connection Error: Cannot execute Commander", e);
				return;
			} catch (WaarpDatabaseSqlException e) {
				try {
					DbModelFactory.dbModel.validConnection(DbConstant.admin.session);
				} catch (WaarpDatabaseNoConnectionException e1) {
				}
				logger.error("Database SQL Error: Cannot execute Commander", e);
				return;
			} catch (WaarpDatabaseException e) {
				try {
					DbModelFactory.dbModel.validConnection(DbConstant.admin.session);
				} catch (WaarpDatabaseNoConnectionException e1) {
				}
				logger.error("Database Error: Cannot execute Commander", e);
				return;
			} finally {
]]>
</codefragment>
</duplication>
<duplication lines="16" tokens="117">
<file line="147" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\client\Message.java"/>
<file line="179" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\client\RequestInformation.java"/>
<codefragment>
<![CDATA[
			logger.debug(Messages.getString("Message.HostNotFound") + requested); //$NON-NLS-1$
			R66Result result = new R66Result(null, true, ErrorCode.ConnectionImpossible, null);
			this.future.setResult(result);
			this.future.cancel();
			return;
		}
		if (host.isClient()) {
			logger.error(Messages.getString("Message.HostIsClient") + requested); //$NON-NLS-1$
			R66Result result = new R66Result(null, true, ErrorCode.ConnectionImpossible, null);
			this.future.setResult(result);
			this.future.cancel();
			return;
		}
		SocketAddress socketAddress = host.getSocketAddress();
		boolean isSSL = host.isSsl();
		LocalChannelReference localChannelReference = null;
]]>
</codefragment>
</duplication>
<duplication lines="22" tokens="117">
<file line="258" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\commander\Commander.java"/>
<file line="365" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\commander\Commander.java"/>
<file line="483" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\commander\Commander.java"/>
<codefragment>
<![CDATA[
			} catch (WaarpDatabaseNoConnectionException e) {
				try {
					DbModelFactory.dbModel.validConnection(DbConstant.admin.session);
				} catch (WaarpDatabaseNoConnectionException e1) {
				}
				logger.error("Database No Connection Error: Cannot execute Commander", e);
				return;
			} catch (WaarpDatabaseSqlException e) {
				try {
					DbModelFactory.dbModel.validConnection(DbConstant.admin.session);
				} catch (WaarpDatabaseNoConnectionException e1) {
				}
				logger.error("Database SQL Error: Cannot execute Commander", e);
				return;
			} catch (WaarpDatabaseException e) {
				try {
					DbModelFactory.dbModel.validConnection(DbConstant.admin.session);
				} catch (WaarpDatabaseNoConnectionException e1) {
				}
				logger.error("Database Error: Cannot execute Commander", e);
				return;
			} finally {
]]>
</codefragment>
</duplication>
<duplication lines="21" tokens="116">
<file line="144" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\server\ChangeBandwidthLimits.java"/>
<file line="137" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\server\LogExport.java"/>
<codefragment>
<![CDATA[
		try {
			ChannelUtils.writeAbstractLocalPacket(localChannelReference, valid, false);
		} catch (OpenR66ProtocolPacketException e) {
			logger.error("Bad Protocol", e);
			Channels.close(localChannelReference.getLocalChannel());
			localChannelReference = null;
			host = null;
			valid = null;
			future.setResult(new R66Result(e, null, true,
					ErrorCode.TransferError, null));
			future.setFailure(e);
			return;
		}
		host = null;
		future.awaitUninterruptibly();
		logger.info("Request done with " + (future.isSuccess() ? "success" : "error"));
		Channels.close(localChannelReference.getLocalChannel());
		localChannelReference = null;
	}

	protected static long swriteGlobalLimit = -1;
]]>
</codefragment>
</duplication>
<duplication lines="19" tokens="115">
<file line="244" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="240" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
				" START WITH " + (DbConstant.ILLEGALVALUE + 1);
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}
	}

	public boolean upgradeDb(DbSession session, String version) throws WaarpDatabaseNoConnectionException {
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_13.getVersion())) {
			System.out.println(version+" to "+R66Versions.V2_4_13.getVersion()+"? "+true);
			String createTableH2 = "CREATE TABLE IF NOT EXISTS ";
]]>
</codefragment>
</duplication>
<duplication lines="14" tokens="112">
<file line="251" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\client\AbstractTransfer.java"/>
<file line="397" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\client\SpooledDirectoryTransfer.java"/>
<codefragment>
<![CDATA[
					rule = args[i];
				} else if (args[i].equalsIgnoreCase("-info")) {
					i++;
					fileInfo = args[i];
				} else if (args[i].equalsIgnoreCase("-md5")) {
					ismd5 = true;
				} else if (args[i].equalsIgnoreCase("-block")) {
					i++;
					block = Integer.parseInt(args[i]);
					if (block < 100) {
						logger.error(Messages.getString("AbstractTransfer.1") + block); //$NON-NLS-1$
						return false;
					}
				} else if (args[i].equalsIgnoreCase("-nolog")) {
]]>
</codefragment>
</duplication>
<duplication lines="18" tokens="112">
<file line="2507" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<file line="3111" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<codefragment>
<![CDATA[
			case LocalPacketFactory.CONFIMPORTPACKET: {
				session.newState(VALIDOTHER);
				// Authentication must be the local server or CONFIGADMIN authorization
				try {
					if (!session.getAuth().getUser().equals(
							Configuration.configuration.getHostId(session.getAuth().isSsl())) &&
							!session.getAuth().isValidRole(ROLE.CONFIGADMIN)) {
						throw new OpenR66ProtocolNotAuthenticatedException(
								"Not correctly authenticated");
					}
				} catch (OpenR66ProtocolNoSslException e1) {
					throw new OpenR66ProtocolNotAuthenticatedException(
							"Not correctly authenticated since SSL is not supported", e1);
				}
				if (Configuration.configuration.r66Mib != null) {
					Configuration.configuration.r66Mib.notifyWarning(
							"Import Configuration Order received", session.getAuth().getUser());
				}
]]>
</codefragment>
</duplication>
<duplication lines="18" tokens="112">
<file line="2427" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<file line="3396" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<codefragment>
<![CDATA[
			case LocalPacketFactory.CONFEXPORTPACKET: {
				session.newState(VALIDOTHER);
				// Authentication must be the local server or CONFIGADMIN authorization
				try {
					if (!session.getAuth().getUser().equals(
							Configuration.configuration.getHostId(session.getAuth().isSsl())) &&
							!session.getAuth().isValidRole(ROLE.CONFIGADMIN)) {
						throw new OpenR66ProtocolNotAuthenticatedException(
								"Not correctly authenticated");
					}
				} catch (OpenR66ProtocolNoSslException e1) {
					throw new OpenR66ProtocolNotAuthenticatedException(
							"Not correctly authenticated since SSL is not supported", e1);
				}
				if (Configuration.configuration.r66Mib != null) {
					Configuration.configuration.r66Mib.notifyWarning(
							"Export Configuration Order received", session.getAuth().getUser());
				}
]]>
</codefragment>
</duplication>
<duplication lines="12" tokens="111">
<file line="523" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\RuleFileBasedConfiguration.java"/>
<file line="537" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\RuleFileBasedConfiguration.java"/>
<file line="551" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\RuleFileBasedConfiguration.java"/>
<file line="565" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\RuleFileBasedConfiguration.java"/>
<file line="579" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\RuleFileBasedConfiguration.java"/>
<codefragment>
<![CDATA[
		if (array != null) {
			for (rank = 0; rank < array.length; rank++) {
				Element task = new DefaultElement(XTASK);
				task.add(newElement(DbRule.TASK_TYPE, array[rank][0]));
				task.add(newElement(DbRule.TASK_PATH, array[rank][1]));
				task.add(newElement(DbRule.TASK_DELAY, array[rank][2]));
				roottasks.add(task);
			}
		}
		tasks.add(roottasks);
		root.add(tasks);
		tasks = new DefaultElement(XRPOSTTASKS);
]]>
</codefragment>
</duplication>
<duplication lines="15" tokens="111">
<file line="97" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="100" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMariadb.java"/>
<file line="100" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="101" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelOracle.java"/>
<file line="93" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
		} catch (WaarpDatabaseException e1) {
			e1.printStackTrace();
		}

		// Configuration
		action = createTableH2 + DbConfiguration.table + "(";
		DbConfiguration.Columns[] ccolumns = DbConfiguration.Columns
				.values();
		for (int i = 0; i < ccolumns.length - 1; i++) {
			action += ccolumns[i].name() +
					DBType.getType(DbConfiguration.dbTypes[i]) + notNull +
					", ";
		}
		action += ccolumns[ccolumns.length - 1].name() +
				DBType.getType(DbConfiguration.dbTypes[ccolumns.length - 1]) +
]]>
</codefragment>
</duplication>
<duplication lines="15" tokens="109">
<file line="174" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\client\DirectTransfer.java"/>
<file line="199" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\client\MultipleDirectTransfer.java"/>
<codefragment>
<![CDATA[
				outputFormat.sysout();
				if (nolog || result.runner.shallIgnoreSave()) {
					// In case of success, delete the runner
					try {
						result.runner.delete();
					} catch (WaarpDatabaseException e) {
						logger.warn("Cannot apply nolog to     " + result.runner.toShortString(),
								e);
					}
				}
			} else {
				if (result == null || result.runner == null) {
					outputFormat.setValue(FIELDS.status.name(), 2);
					outputFormat.setValue(FIELDS.statusTxt.name(), Messages.getString("Transfer.FailedNoId")); //$NON-NLS-1$
					outputFormat.setValue(FIELDS.remote.name(), rhost);
]]>
</codefragment>
</duplication>
<duplication lines="20" tokens="109">
<file line="224" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="227" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMariadb.java"/>
<file line="227" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="232" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelOracle.java"/>
<file line="220" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
		action = "CREATE INDEX IF NOT EXISTS IDX_RUNNER ON " + DbTaskRunner.table + "(";
		DbTaskRunner.Columns[] icolumns = DbTaskRunner.indexes;
		for (int i = 0; i < icolumns.length - 1; i++) {
			action += icolumns[i].name() + ", ";
		}
		action += icolumns[icolumns.length - 1].name() + ")";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// cptrunner
		action = "CREATE SEQUENCE IF NOT EXISTS " + DbTaskRunner.fieldseq +
]]>
</codefragment>
</duplication>
<duplication lines="12" tokens="109">
<file line="128" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="267" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="131" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMariadb.java"/>
<file line="291" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMariadb.java"/>
<file line="131" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="291" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="124" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<file line="263" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
		action = createTableH2 + DbHostConfiguration.table + "(";
		DbHostConfiguration.Columns[] chcolumns = DbHostConfiguration.Columns
				.values();
		for (int i = 0; i < chcolumns.length - 1; i++) {
			action += chcolumns[i].name() +
					DBType.getType(DbHostConfiguration.dbTypes[i]) + notNull +
					", ";
		}
		action += chcolumns[chcolumns.length - 1].name() +
				DBType.getType(DbHostConfiguration.dbTypes[chcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
]]>
</codefragment>
</duplication>
<duplication lines="21" tokens="108">
<file line="2487" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<file line="2611" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<codefragment>
<![CDATA[
					}
				}
				R66Result result = null;
				if (brule || bhost) {
					result = new R66Result(session, true, ErrorCode.CompleteOk, null);
				} else {
					result = new R66Result(session, true, ErrorCode.TransferError, null);
				}
				// Now answer
				ValidPacket valid = new ValidPacket(shost + " " + srule, result.code.getCode(),
						LocalPacketFactory.REQUESTUSERPACKET);
				localChannelReference.validateRequest(result);
				try {
					ChannelUtils.writeAbstractLocalPacket(localChannelReference,
							valid, true);
				} catch (OpenR66ProtocolPacketException e) {
				}
				Channels.close(channel);
				break;
			}
			case LocalPacketFactory.CONFIMPORTPACKET: {
]]>
</codefragment>
</duplication>
<duplication lines="9" tokens="107">
<file line="615" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<file line="634" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<codefragment>
<![CDATA[
					configNetworkServerDecls, false),
			new XmlDecl(XML_SSL, XmlType.XVAL, XML_ROOT + XML_SSL, configSslDecls, false),
			new XmlDecl(XML_DIRECTORY, XmlType.XVAL, XML_ROOT + XML_DIRECTORY,
					configDirectoryDecls, false),
			new XmlDecl(XML_LIMIT, XmlType.XVAL, XML_ROOT + XML_LIMIT, configLimitDecls, false),
			new XmlDecl(XML_DB, XmlType.XVAL, XML_ROOT + XML_DB, configDbDecls, false),
			new XmlDecl(DbHostConfiguration.XML_BUSINESS, XmlType.STRING, XML_ROOT + DbHostConfiguration.XML_BUSINESS + "/"
					+ DbHostConfiguration.XML_BUSINESSID, true),
			new XmlDecl(DbHostConfiguration.XML_ROLES, XmlType.XVAL, XML_ROOT + DbHostConfiguration.XML_ROLES + "/"
]]>
</codefragment>
</duplication>
<duplication lines="18" tokens="107">
<file line="314" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\context\task\RescheduleTransferTask.java"/>
<file line="361" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\context\task\RescheduleTransferTask.java"/>
<codefragment>
<![CDATA[
				String[] elmts = args[i].split(";");
				boolean startModified = false;
				String[] values = elmts[0].split(":");
				Calendar start = getCalendar(values);
				if (start != null) {
					startModified = true;
				} else {
					start = Calendar.getInstance();
				}
				boolean stopModified = false;
				values = elmts[1].split(":");
				Calendar stop = getCalendar(values);
				if (stop != null) {
					stopModified = true;
				} else {
					stop = Calendar.getInstance();
				}
				logger.debug("Dates before check: Not between " + start.getTime() + " and "
]]>
</codefragment>
</duplication>
<duplication lines="14" tokens="107">
<file line="64" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="67" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMariadb.java"/>
<file line="67" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="65" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelOracle.java"/>
<file line="60" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
		String primaryKey = " PRIMARY KEY ";
		String notNull = " NOT NULL ";

		// Multiple Mode
		String action = createTableH2 + DbMultipleMonitor.table + "(";
		DbMultipleMonitor.Columns[] mcolumns = DbMultipleMonitor.Columns
				.values();
		for (int i = 0; i < mcolumns.length - 1; i++) {
			action += mcolumns[i].name() +
					DBType.getType(DbMultipleMonitor.dbTypes[i]) + notNull +
					", ";
		}
		action += mcolumns[mcolumns.length - 1].name() +
				DBType.getType(DbMultipleMonitor.dbTypes[mcolumns.length - 1]) +
]]>
</codefragment>
</duplication>
<duplication lines="15" tokens="107">
<file line="123" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="126" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMariadb.java"/>
<file line="126" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="128" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelOracle.java"/>
<file line="119" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
		} finally {
			request.close();
		}

		// HostConfiguration
		action = createTableH2 + DbHostConfiguration.table + "(";
		DbHostConfiguration.Columns[] chcolumns = DbHostConfiguration.Columns
				.values();
		for (int i = 0; i < chcolumns.length - 1; i++) {
			action += chcolumns[i].name() +
					DBType.getType(DbHostConfiguration.dbTypes[i]) + notNull +
					", ";
		}
		action += chcolumns[chcolumns.length - 1].name() +
				DBType.getType(DbHostConfiguration.dbTypes[chcolumns.length - 1]) +
]]>
</codefragment>
</duplication>
<duplication lines="18" tokens="107">
<file line="269" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMariadb.java"/>
<file line="269" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="241" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}
	}

	public boolean upgradeDb(DbSession session, String version) throws WaarpDatabaseNoConnectionException {
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_13.getVersion())) {
			System.out.println(version+" to "+R66Versions.V2_4_13.getVersion()+"? "+true);
			String createTableH2 = "CREATE TABLE IF NOT EXISTS ";
]]>
</codefragment>
</duplication>
<duplication lines="14" tokens="107">
<file line="263" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="287" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMariadb.java"/>
<file line="287" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="272" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelOracle.java"/>
<file line="259" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
			String primaryKey = " PRIMARY KEY ";
			String notNull = " NOT NULL ";
	
			// HostConfiguration
			String action = createTableH2 + DbHostConfiguration.table + "(";
			DbHostConfiguration.Columns[] chcolumns = DbHostConfiguration.Columns
					.values();
			for (int i = 0; i < chcolumns.length - 1; i++) {
				action += chcolumns[i].name() +
						DBType.getType(DbHostConfiguration.dbTypes[i]) + notNull +
						", ";
			}
			action += chcolumns[chcolumns.length - 1].name() +
					DBType.getType(DbHostConfiguration.dbTypes[chcolumns.length - 1]) +
]]>
</codefragment>
</duplication>
<duplication lines="11" tokens="106">
<file line="523" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\RuleFileBasedConfiguration.java"/>
<file line="537" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\RuleFileBasedConfiguration.java"/>
<file line="551" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\RuleFileBasedConfiguration.java"/>
<file line="565" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\RuleFileBasedConfiguration.java"/>
<file line="579" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\RuleFileBasedConfiguration.java"/>
<file line="593" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\RuleFileBasedConfiguration.java"/>
<codefragment>
<![CDATA[
		if (array != null) {
			for (rank = 0; rank < array.length; rank++) {
				Element task = new DefaultElement(XTASK);
				task.add(newElement(DbRule.TASK_TYPE, array[rank][0]));
				task.add(newElement(DbRule.TASK_PATH, array[rank][1]));
				task.add(newElement(DbRule.TASK_DELAY, array[rank][2]));
				roottasks.add(task);
			}
		}
		tasks.add(roottasks);
		root.add(tasks);
]]>
</codefragment>
</duplication>
<duplication lines="17" tokens="105">
<file line="80" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\client\Message.java"/>
<file line="86" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\client\RequestInformation.java"/>
<codefragment>
<![CDATA[
		 _INFO_ARGS = Messages.getString("Message.0")+ Messages.getString("Message.OutputFormat"); //$NON-NLS-1$
		if (args.length < 5) {
			logger
					.error(_INFO_ARGS);
			return false;
		}
		if (!FileBasedConfiguration
				.setClientConfigurationFromXml(Configuration.configuration, args[0])) {
			logger
					.error(Messages.getString("Configuration.NeedCorrectConfig")); //$NON-NLS-1$
			return false;
		}
		for (int i = 1; i < args.length; i++) {
			if (args[i].equalsIgnoreCase("-to")) {
				i++;
				srequested = args[i];
			} else if (args[i].equalsIgnoreCase("-msg")) {
]]>
</codefragment>
</duplication>
<duplication lines="13" tokens="105">
<file line="171" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="174" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMariadb.java"/>
<file line="174" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="179" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelOracle.java"/>
<file line="167" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
		} finally {
			request.close();
		}

		// rules
		action = createTableH2 + DbRule.table + "(";
		DbRule.Columns[] rcolumns = DbRule.Columns.values();
		for (int i = 0; i < rcolumns.length - 1; i++) {
			action += rcolumns[i].name() +
					DBType.getType(DbRule.dbTypes[i]) + ", ";
		}
		action += rcolumns[rcolumns.length - 1].name() +
				DBType.getType(DbRule.dbTypes[rcolumns.length - 1]) +
]]>
</codefragment>
</duplication>
<duplication lines="22" tokens="101">
<file line="2095" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<file line="2158" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<codefragment>
<![CDATA[
		}
		config.HOST_AUTH = R66Auth.getServerAuth(
				DbConstant.admin.session, config.HOST_ID);
		if (config.HOST_AUTH == null) {
			logger.error("Cannot find Authentication for current host");
			return false;
		}
		if (config.HOST_SSLID != null) {
			config.HOST_SSLAUTH = R66Auth.getServerAuth(
					DbConstant.admin.session,
					config.HOST_SSLID);
			if (config.HOST_SSLAUTH == null) {
				logger.error("Cannot find SSL Authentication for current host");
				return false;
			}
		}
		loadBusinessWhiteList(config);
		hashConfig.clear();
		hashConfig = null;
		configuration = null;
		return true;
	}
]]>
</codefragment>
</duplication>
<duplication lines="13" tokens="101">
<file line="756" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbRule.java"/>
<file line="777" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbRule.java"/>
<codefragment>
<![CDATA[
			setFromArrayClone(rule);
			if (recvPath == null || recvPath.trim().isEmpty()) {
				recvPath = Configuration.configuration.inPath;
			}
			if (sendPath == null || sendPath.trim().isEmpty()) {
				sendPath = Configuration.configuration.outPath;
			}
			if (archivePath == null || archivePath.trim().isEmpty()) {
				archivePath = Configuration.configuration.archivePath;
			}
			if (workPath == null || workPath.trim().isEmpty()) {
				workPath = Configuration.configuration.workingPath;
			}
]]>
</codefragment>
</duplication>
<duplication lines="17" tokens="100">
<file line="145" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\context\task\ExecMoveTask.java"/>
<file line="150" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\context\task\ExecOutputTask.java"/>
<codefragment>
<![CDATA[
		Thread thread = new Thread(lastLineReader, "ExecRename"
				+ session.getRunner().getSpecialId());
		thread.setDaemon(true);
		Configuration.configuration.getExecutorService().execute(thread);
		int status = -1;
		try {
			status = defaultExecutor.execute(commandLine);
		} catch (ExecuteException e) {
			if (e.getExitValue() == -559038737) {
				// Cannot run immediately so retry once
				try {
					Thread.sleep(Configuration.RETRYINMS);
				} catch (InterruptedException e1) {
				}
				try {
					status = defaultExecutor.execute(commandLine);
				} catch (ExecuteException e1) {
]]>
</codefragment>
</duplication>
<duplication lines="16" tokens="100">
<file line="2427" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<file line="2507" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<codefragment>
<![CDATA[
			case LocalPacketFactory.CONFEXPORTPACKET: {
				session.newState(VALIDOTHER);
				// Authentication must be the local server or CONFIGADMIN authorization
				try {
					if (!session.getAuth().getUser().equals(
							Configuration.configuration.getHostId(session.getAuth().isSsl())) &&
							!session.getAuth().isValidRole(ROLE.CONFIGADMIN)) {
						throw new OpenR66ProtocolNotAuthenticatedException(
								"Not correctly authenticated");
					}
				} catch (OpenR66ProtocolNoSslException e1) {
					throw new OpenR66ProtocolNotAuthenticatedException(
							"Not correctly authenticated since SSL is not supported", e1);
				}
				if (Configuration.configuration.r66Mib != null) {
					Configuration.configuration.r66Mib.notifyWarning(
]]>
</codefragment>
</duplication>
</pmd-cpd>