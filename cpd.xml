<?xml version="1.0" encoding="UTF-8"?>
<pmd-cpd>
<duplication lines="187" tokens="1110">
<file line="67" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="60" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
		String primaryKey = " PRIMARY KEY ";
		String notNull = " NOT NULL ";

		// Multiple Mode
		String action = createTableH2 + DbMultipleMonitor.table + "(";
		DbMultipleMonitor.Columns[] mcolumns = DbMultipleMonitor.Columns
				.values();
		for (int i = 0; i < mcolumns.length - 1; i++) {
			action += mcolumns[i].name() +
					DBType.getType(DbMultipleMonitor.dbTypes[i]) + notNull +
					", ";
		}
		action += mcolumns[mcolumns.length - 1].name() +
				DBType.getType(DbMultipleMonitor.dbTypes[mcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		DbRequest request = new DbRequest(session);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}
		DbMultipleMonitor multipleMonitor = new DbMultipleMonitor(session,
				Configuration.configuration.HOST_ID, 0, 0, 0);
		try {
			if (!multipleMonitor.exist())
				multipleMonitor.insert();
		} catch (WaarpDatabaseException e1) {
			e1.printStackTrace();
		}

		// Configuration
		action = createTableH2 + DbConfiguration.table + "(";
		DbConfiguration.Columns[] ccolumns = DbConfiguration.Columns
				.values();
		for (int i = 0; i < ccolumns.length - 1; i++) {
			action += ccolumns[i].name() +
					DBType.getType(DbConfiguration.dbTypes[i]) + notNull +
					", ";
		}
		action += ccolumns[ccolumns.length - 1].name() +
				DBType.getType(DbConfiguration.dbTypes[ccolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		request = new DbRequest(session);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// HostConfiguration
		action = createTableH2 + DbHostConfiguration.table + "(";
		DbHostConfiguration.Columns[] chcolumns = DbHostConfiguration.Columns
				.values();
		for (int i = 0; i < chcolumns.length - 1; i++) {
			action += chcolumns[i].name() +
					DBType.getType(DbHostConfiguration.dbTypes[i]) + notNull +
					", ";
		}
		action += chcolumns[chcolumns.length - 1].name() +
				DBType.getType(DbHostConfiguration.dbTypes[chcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		request = new DbRequest(session);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			// XXX FIX no return;
		} finally {
			request.close();
		}
		
		// hosts
		action = createTableH2 + DbHostAuth.table + "(";
		DbHostAuth.Columns[] hcolumns = DbHostAuth.Columns.values();
		for (int i = 0; i < hcolumns.length - 1; i++) {
			action += hcolumns[i].name() +
					DBType.getType(DbHostAuth.dbTypes[i]) + notNull + ", ";
		}
		action += hcolumns[hcolumns.length - 1].name() +
				DBType.getType(DbHostAuth.dbTypes[hcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// rules
		action = createTableH2 + DbRule.table + "(";
		DbRule.Columns[] rcolumns = DbRule.Columns.values();
		for (int i = 0; i < rcolumns.length - 1; i++) {
			action += rcolumns[i].name() +
					DBType.getType(DbRule.dbTypes[i]) + ", ";
		}
		action += rcolumns[rcolumns.length - 1].name() +
				DBType.getType(DbRule.dbTypes[rcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// runner
		action = createTableH2 + DbTaskRunner.table + "(";
		DbTaskRunner.Columns[] acolumns = DbTaskRunner.Columns.values();
		for (int i = 0; i < acolumns.length; i++) {
			action += acolumns[i].name() +
					DBType.getType(DbTaskRunner.dbTypes[i]) + notNull + ", ";
		}
		// Several columns for primary key
		action += " CONSTRAINT runner_pk " + primaryKey + "(";
		for (int i = DbTaskRunner.NBPRKEY; i > 1; i--) {
			action += acolumns[acolumns.length - i].name() + ",";
		}
		action += acolumns[acolumns.length - 1].name() + "))";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}
		// Index Runner
		action = "CREATE INDEX IDX_RUNNER ON " + DbTaskRunner.table + "(";
		DbTaskRunner.Columns[] icolumns = DbTaskRunner.indexes;
		for (int i = 0; i < icolumns.length - 1; i++) {
			action += icolumns[i].name() + ", ";
		}
		action += icolumns[icolumns.length - 1].name() + ")";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// cptrunner
		/*
		 * # Table to handle any number of sequences: CREATE TABLE Sequences ( name VARCHAR(22) NOT
		 * NULL, seq INT UNSIGNED NOT NULL, # (or BIGINT) PRIMARY KEY name ); # Create a Sequence:
		 * INSERT INTO Sequences (name, seq) VALUES (?, 0); # Drop a Sequence: DELETE FROM Sequences
		 * WHERE name = ?; # Get a sequence number: UPDATE Sequences SET seq = LAST_INSERT_ID(seq +
		 * 1) WHERE name = ?; $seq = $db->LastInsertId();
		 */
		action = "CREATE TABLE Sequences (name VARCHAR(22) NOT NULL PRIMARY KEY," +
]]>
</codefragment>
</duplication>
<duplication lines="165" tokens="1016">
<file line="60" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="63" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<codefragment>
<![CDATA[
	@Override
	public void createTables(DbSession session) throws WaarpDatabaseNoConnectionException {
		// Create tables: configuration, hosts, rules, runner, cptrunner
		String createTableH2 = "CREATE TABLE IF NOT EXISTS ";
		String primaryKey = " PRIMARY KEY ";
		String notNull = " NOT NULL ";

		// Multiple Mode
		String action = createTableH2 + DbMultipleMonitor.table + "(";
		DbMultipleMonitor.Columns[] mcolumns = DbMultipleMonitor.Columns
				.values();
		for (int i = 0; i < mcolumns.length - 1; i++) {
			action += mcolumns[i].name() +
					DBType.getType(DbMultipleMonitor.dbTypes[i]) + notNull +
					", ";
		}
		action += mcolumns[mcolumns.length - 1].name() +
				DBType.getType(DbMultipleMonitor.dbTypes[mcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		DbRequest request = new DbRequest(session);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}
		DbMultipleMonitor multipleMonitor = new DbMultipleMonitor(session,
				Configuration.configuration.HOST_ID, 0, 0, 0);
		try {
			if (!multipleMonitor.exist())
				multipleMonitor.insert();
		} catch (WaarpDatabaseException e1) {
			e1.printStackTrace();
		}

		// Configuration
		action = createTableH2 + DbConfiguration.table + "(";
		DbConfiguration.Columns[] ccolumns = DbConfiguration.Columns
				.values();
		for (int i = 0; i < ccolumns.length - 1; i++) {
			action += ccolumns[i].name() +
					DBType.getType(DbConfiguration.dbTypes[i]) + notNull +
					", ";
		}
		action += ccolumns[ccolumns.length - 1].name() +
				DBType.getType(DbConfiguration.dbTypes[ccolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		request = new DbRequest(session);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// HostConfiguration
		action = createTableH2 + DbHostConfiguration.table + "(";
		DbHostConfiguration.Columns[] chcolumns = DbHostConfiguration.Columns
				.values();
		for (int i = 0; i < chcolumns.length - 1; i++) {
			action += chcolumns[i].name() +
					DBType.getType(DbHostConfiguration.dbTypes[i]) + notNull +
					", ";
		}
		action += chcolumns[chcolumns.length - 1].name() +
				DBType.getType(DbHostConfiguration.dbTypes[chcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		request = new DbRequest(session);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			// XXX FIX no return;
		} finally {
			request.close();
		}
				
		// hosts
		action = createTableH2 + DbHostAuth.table + "(";
		DbHostAuth.Columns[] hcolumns = DbHostAuth.Columns.values();
		for (int i = 0; i < hcolumns.length - 1; i++) {
			action += hcolumns[i].name() +
					DBType.getType(DbHostAuth.dbTypes[i]) + notNull + ", ";
		}
		action += hcolumns[hcolumns.length - 1].name() +
				DBType.getType(DbHostAuth.dbTypes[hcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// rules
		action = createTableH2 + DbRule.table + "(";
		DbRule.Columns[] rcolumns = DbRule.Columns.values();
		for (int i = 0; i < rcolumns.length - 1; i++) {
			action += rcolumns[i].name() +
					DBType.getType(DbRule.dbTypes[i]) + ", ";
		}
		action += rcolumns[rcolumns.length - 1].name() +
				DBType.getType(DbRule.dbTypes[rcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// runner
		action = createTableH2 + DbTaskRunner.table + "(";
		DbTaskRunner.Columns[] acolumns = DbTaskRunner.Columns.values();
		for (int i = 0; i < acolumns.length; i++) {
			action += acolumns[i].name() +
					DBType.getType(DbTaskRunner.dbTypes[i]) + notNull + ", ";
		}
		// Several columns for primary key
		action += " CONSTRAINT runner_pk " + primaryKey + "(";
		for (int i = DbTaskRunner.NBPRKEY; i > 1; i--) {
			action += acolumns[acolumns.length - i].name() + ",";
		}
		action += acolumns[acolumns.length - 1].name() + "))";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}
		// Index Runner
		action = "CREATE INDEX IF NOT EXISTS IDX_RUNNER ON " + DbTaskRunner.table + "(";
]]>
</codefragment>
</duplication>
<duplication lines="161" tokens="1000">
<file line="64" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="60" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
		String primaryKey = " PRIMARY KEY ";
		String notNull = " NOT NULL ";

		// Multiple Mode
		String action = createTableH2 + DbMultipleMonitor.table + "(";
		DbMultipleMonitor.Columns[] mcolumns = DbMultipleMonitor.Columns
				.values();
		for (int i = 0; i < mcolumns.length - 1; i++) {
			action += mcolumns[i].name() +
					DBType.getType(DbMultipleMonitor.dbTypes[i]) + notNull +
					", ";
		}
		action += mcolumns[mcolumns.length - 1].name() +
				DBType.getType(DbMultipleMonitor.dbTypes[mcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		DbRequest request = new DbRequest(session);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}
		DbMultipleMonitor multipleMonitor = new DbMultipleMonitor(session,
				Configuration.configuration.HOST_ID, 0, 0, 0);
		try {
			if (!multipleMonitor.exist())
				multipleMonitor.insert();
		} catch (WaarpDatabaseException e1) {
			e1.printStackTrace();
		}

		// Configuration
		action = createTableH2 + DbConfiguration.table + "(";
		DbConfiguration.Columns[] ccolumns = DbConfiguration.Columns
				.values();
		for (int i = 0; i < ccolumns.length - 1; i++) {
			action += ccolumns[i].name() +
					DBType.getType(DbConfiguration.dbTypes[i]) + notNull +
					", ";
		}
		action += ccolumns[ccolumns.length - 1].name() +
				DBType.getType(DbConfiguration.dbTypes[ccolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		request = new DbRequest(session);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// HostConfiguration
		action = createTableH2 + DbHostConfiguration.table + "(";
		DbHostConfiguration.Columns[] chcolumns = DbHostConfiguration.Columns
				.values();
		for (int i = 0; i < chcolumns.length - 1; i++) {
			action += chcolumns[i].name() +
					DBType.getType(DbHostConfiguration.dbTypes[i]) + notNull +
					", ";
		}
		action += chcolumns[chcolumns.length - 1].name() +
				DBType.getType(DbHostConfiguration.dbTypes[chcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		request = new DbRequest(session);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			// XXX FIX no return;
		} finally {
			request.close();
		}
				
		// hosts
		action = createTableH2 + DbHostAuth.table + "(";
		DbHostAuth.Columns[] hcolumns = DbHostAuth.Columns.values();
		for (int i = 0; i < hcolumns.length - 1; i++) {
			action += hcolumns[i].name() +
					DBType.getType(DbHostAuth.dbTypes[i]) + notNull + ", ";
		}
		action += hcolumns[hcolumns.length - 1].name() +
				DBType.getType(DbHostAuth.dbTypes[hcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// rules
		action = createTableH2 + DbRule.table + "(";
		DbRule.Columns[] rcolumns = DbRule.Columns.values();
		for (int i = 0; i < rcolumns.length - 1; i++) {
			action += rcolumns[i].name() +
					DBType.getType(DbRule.dbTypes[i]) + ", ";
		}
		action += rcolumns[rcolumns.length - 1].name() +
				DBType.getType(DbRule.dbTypes[rcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// runner
		action = createTableH2 + DbTaskRunner.table + "(";
		DbTaskRunner.Columns[] acolumns = DbTaskRunner.Columns.values();
		for (int i = 0; i < acolumns.length; i++) {
			action += acolumns[i].name() +
					DBType.getType(DbTaskRunner.dbTypes[i]) + notNull + ", ";
		}
		// Several columns for primary key
		action += " CONSTRAINT runner_pk " + primaryKey + "(";
		for (int i = DbTaskRunner.NBPRKEY; i > 1; i--) {
			action += acolumns[acolumns.length - i].name() + ",";
		}
		action += acolumns[acolumns.length - 1].name() + "))";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}
		// Index Runner
		action = "CREATE INDEX IF NOT EXISTS IDX_RUNNER ON " + DbTaskRunner.table + "(";
]]>
</codefragment>
</duplication>
<duplication lines="107" tokens="513">
<file line="299" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="293" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
				request.query(command);
			} catch (WaarpDatabaseSqlException e) {
				e.printStackTrace();
				return false;
			} finally {
				request.close();
			}
		}
		return true;
	}
	
	/*
	 * (non-Javadoc)
	 * @see org.waarp.openr66.databaseold.model.DbModel#resetSequence()
	 */
	@Override
	public void resetSequence(DbSession session, long newvalue)
			throws WaarpDatabaseNoConnectionException {
		String action = "ALTER SEQUENCE " + DbTaskRunner.fieldseq +
				" RESTART WITH " + newvalue;
		DbRequest request = new DbRequest(session);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			return;
		} finally {
			request.close();
		}
		System.out.println(action);
	}

	/*
	 * (non-Javadoc)
	 * @see org.waarp.openr66.databaseold.model.DbModel#nextSequence()
	 */
	@Override
	public long nextSequence(DbSession dbSession)
			throws WaarpDatabaseNoConnectionException,
			WaarpDatabaseSqlException, WaarpDatabaseNoDataException {
		long result = DbConstant.ILLEGALVALUE;
		String action = "SELECT NEXTVAL('" + DbTaskRunner.fieldseq + "')";
		DbPreparedStatement preparedStatement = new DbPreparedStatement(
				dbSession);
		try {
			preparedStatement.createPrepareStatement(action);
			// Limit the search
			preparedStatement.executeQuery();
			if (preparedStatement.getNext()) {
				try {
					result = preparedStatement.getResultSet().getLong(1);
				} catch (SQLException e) {
					throw new WaarpDatabaseSqlException(e);
				}
				return result;
			} else {
				throw new WaarpDatabaseNoDataException(
						"No sequence found. Must be initialized first");
			}
		} finally {
			preparedStatement.realClose();
		}
	}

	public boolean needUpgradeDb(DbSession session, String version, boolean tryFix)
			throws WaarpDatabaseNoConnectionException {
		// Check if the database is up to date
		DbRequest request = null;
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_13.getVersion())) {
			try {
				request = new DbRequest(DbConstant.admin.session);
				request.select("select "+DbHostConfiguration.Columns.HOSTID.name()+" from "+DbHostConfiguration.table+
						" where "+DbHostConfiguration.Columns.HOSTID+" = '"+Configuration.configuration.HOST_ID+"'");
				request.close();
				DbHostConfiguration.updateVersionDb(session, Configuration.configuration.HOST_ID, R66Versions.V2_4_13.getVersion());
			} catch (WaarpDatabaseSqlException e) {
				return ! upgradeDb(session, version);
			} finally {
				if (request != null) {
					request.close();
				}
			}
		}
		request = null;
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_17.getVersion())) {
			try {
				request = new DbRequest(DbConstant.admin.session);
				request.select("select "+DbTaskRunner.Columns.TRANSFERINFO.name()+" from "+DbTaskRunner.table+
						" where "+DbTaskRunner.Columns.SPECIALID+" = "+DbConstant.ILLEGALVALUE);
				request.close();
				DbHostConfiguration.updateVersionDb(session, Configuration.configuration.HOST_ID, R66Versions.V2_4_17.getVersion());
			} catch (WaarpDatabaseSqlException e) {
				return ! upgradeDb(session, version);
			} finally {
				if (request != null) {
					request.close();
				}
			}
		}
		return false;
	}
	
	
}
]]>
</codefragment>
</duplication>
<duplication lines="62" tokens="361">
<file line="344" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="357" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelOracle.java"/>
<file line="338" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
		DbPreparedStatement preparedStatement = new DbPreparedStatement(
				dbSession);
		try {
			preparedStatement.createPrepareStatement(action);
			// Limit the search
			preparedStatement.executeQuery();
			if (preparedStatement.getNext()) {
				try {
					result = preparedStatement.getResultSet().getLong(1);
				} catch (SQLException e) {
					throw new WaarpDatabaseSqlException(e);
				}
				return result;
			} else {
				throw new WaarpDatabaseNoDataException(
						"No sequence found. Must be initialized first");
			}
		} finally {
			preparedStatement.realClose();
		}
	}

	public boolean needUpgradeDb(DbSession session, String version, boolean tryFix)
			throws WaarpDatabaseNoConnectionException {
		// Check if the database is up to date
		DbRequest request = null;
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_13.getVersion())) {
			try {
				request = new DbRequest(DbConstant.admin.session);
				request.select("select "+DbHostConfiguration.Columns.HOSTID.name()+" from "+DbHostConfiguration.table+
						" where "+DbHostConfiguration.Columns.HOSTID+" = '"+Configuration.configuration.HOST_ID+"'");
				request.close();
				DbHostConfiguration.updateVersionDb(session, Configuration.configuration.HOST_ID, R66Versions.V2_4_13.getVersion());
			} catch (WaarpDatabaseSqlException e) {
				return ! upgradeDb(session, version);
			} finally {
				if (request != null) {
					request.close();
				}
			}
		}
		request = null;
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_17.getVersion())) {
			try {
				request = new DbRequest(DbConstant.admin.session);
				request.select("select "+DbTaskRunner.Columns.TRANSFERINFO.name()+" from "+DbTaskRunner.table+
						" where "+DbTaskRunner.Columns.SPECIALID+" = "+DbConstant.ILLEGALVALUE);
				request.close();
				DbHostConfiguration.updateVersionDb(session, Configuration.configuration.HOST_ID, R66Versions.V2_4_17.getVersion());
			} catch (WaarpDatabaseSqlException e) {
				return ! upgradeDb(session, version);
			} finally {
				if (request != null) {
					request.close();
				}
			}
		}
		return false;
	}
	
	
}
]]>
</codefragment>
</duplication>
<duplication lines="49" tokens="349">
<file line="338" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\http\adminssl\HttpSslHandler.java"/>
<file line="453" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\http\adminssl\HttpSslHandler.java"/>
<codefragment>
<![CDATA[
			body0 = REQUEST.Listing.readBodyHeader();
			String parm = parms.get(0);
			if ("Filter".equalsIgnoreCase(parm)) {
				String startid = getTrimValue("startid");
				String stopid = getTrimValue("stopid");
				if (startid != null && stopid == null) {
					try {
                 		stopid = Long.toString(Long.parseLong(startid)+(LIMITROW/2));
                    } catch (NumberFormatException e) {
                     	stopid = null;
                     	startid = null;
                    }
				}
				if (stopid != null && startid == null) {
					try {
						startid = Long.toString(Long.parseLong(stopid) - (LIMITROW / 2));
                    } catch (NumberFormatException e) {
                     	stopid = null;
                     	startid = null;
                    }
				}
				String start = getValue("start");
				String stop = getValue("stop");
				String rule = getTrimValue("rule");
				String req = getTrimValue("req");
				boolean pending, transfer, error, done, all;
				pending = params.containsKey("pending");
				transfer = params.containsKey("transfer");
				error = params.containsKey("error");
				done = params.containsKey("done");
				all = params.containsKey("all");
				if (pending && transfer && error && done) {
					all = true;
				} else if (!(pending || transfer || error || done)) {
					all = true;
				}
				Timestamp tstart = WaarpStringUtils.fixDate(start);
				if (tstart != null) {
					start = tstart.toString();
				}
				Timestamp tstop = WaarpStringUtils.fixDate(stop, tstart);
				if (tstop != null) {
					stop = tstop.toString();
				}
				head = resetOptionTransfer(head, startid == null ? "" : startid,
						stopid == null ? "" : stopid, start, stop,
						rule == null ? "" : rule, req == null ? "" : req,
						pending, transfer, error, done, all);
				body = REQUEST.Listing.readBody();
]]>
</codefragment>
</duplication>
<duplication lines="47" tokens="315">
<file line="245" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="269" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<codefragment>
<![CDATA[
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}
	}

	public boolean upgradeDb(DbSession session, String version) throws WaarpDatabaseNoConnectionException {
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_13.getVersion())) {
			System.out.println(version+" to "+R66Versions.V2_4_13.getVersion()+"? "+true);
			String createTableH2 = "CREATE TABLE IF NOT EXISTS ";
			String primaryKey = " PRIMARY KEY ";
			String notNull = " NOT NULL ";
	
			// HostConfiguration
			String action = createTableH2 + DbHostConfiguration.table + "(";
			DbHostConfiguration.Columns[] chcolumns = DbHostConfiguration.Columns
					.values();
			for (int i = 0; i < chcolumns.length - 1; i++) {
				action += chcolumns[i].name() +
						DBType.getType(DbHostConfiguration.dbTypes[i]) + notNull +
						", ";
			}
			action += chcolumns[chcolumns.length - 1].name() +
					DBType.getType(DbHostConfiguration.dbTypes[chcolumns.length - 1]) +
					primaryKey + ")";
			System.out.println(action);
			DbRequest request = new DbRequest(session);
			try {
				request.query(action);
			} catch (WaarpDatabaseSqlException e) {
				e.printStackTrace();
				return false;
			} finally {
				request.close();
			}
		}
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_17.getVersion())) {
			System.out.println(version+" to "+R66Versions.V2_4_17.getVersion()+"? "+true);
			String command = "ALTER TABLE "+DbTaskRunner.table+" ADD COLUMN IF NOT EXISTS "+
]]>
</codefragment>
</duplication>
<duplication lines="58" tokens="315">
<file line="2612" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<file line="3563" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<codefragment>
<![CDATA[
					}
				}
				// check if send is already on going
				if (session.getRunner() != null && session.getRunner().getRank() > 0) {
					// already started so not changing the filename
					// Success: No write back at all
					break;
				}
				// Pre execution was already done since this packet is only received once
				// the request is already validated by the receiver
				try {
					session.renameReceiverFile(newfilename);
				} catch (OpenR66RunnerErrorException e) {
					DbTaskRunner runner = session.getRunner();
					runner.saveStatus();
					runner.setErrorExecutionStatus(ErrorCode.FileNotFound);
					session.newState(ERROR);
					logger.error("File renaming in error {}", e.getMessage());
					ErrorPacket error = new ErrorPacket("File renaming in error: " + e
							.getMessage(), runner.getErrorInfo().getCode(),
							ErrorPacket.FORWARDCLOSECODE);
					try {
						ChannelUtils.writeAbstractLocalPacket(localChannelReference,
								error, true);
					} catch (OpenR66ProtocolPacketException e2) {
					}
					try {
						session.setFinalizeTransfer(false, new R66Result(e, session,
								true, runner.getErrorInfo(), runner));
					} catch (OpenR66RunnerErrorException e1) {
						localChannelReference.invalidateRequest(new R66Result(e, session,
								true, runner.getErrorInfo(), runner));
					} catch (OpenR66ProtocolSystemException e1) {
						localChannelReference.invalidateRequest(new R66Result(e, session,
								true, runner.getErrorInfo(), runner));
					}
					session.setStatus(97);
					ChannelCloseTimer.closeFutureChannel(channel);
					return;
				}
				// Success: No write back at all
				break;
			}
			case LocalPacketFactory.BANDWIDTHPACKET: {
				session.newState(VALIDOTHER);
				// should be from the local server or from an authorized hosts: LIMIT
				// Authentication must be the local server or SYSTEM authorization
				try {
					if (!session.getAuth().getUser().equals(
							Configuration.configuration.getHostId(session.getAuth().isSsl())) &&
							!session.getAuth().isValidRole(ROLE.LIMIT)) {
						throw new OpenR66ProtocolNotAuthenticatedException(
								"Not correctly authenticated");
					}
				} catch (OpenR66ProtocolNoSslException e1) {
					throw new OpenR66ProtocolNotAuthenticatedException(
							"Not correctly authenticated since SSL is not supported", e1);
				}
]]>
</codefragment>
</duplication>
<duplication lines="44" tokens="285">
<file line="362" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="408" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="375" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelOracle.java"/>
<file line="356" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
			preparedStatement.realClose();
		}
	}

	public boolean needUpgradeDb(DbSession session, String version, boolean tryFix)
			throws WaarpDatabaseNoConnectionException {
		// Check if the database is up to date
		DbRequest request = null;
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_13.getVersion())) {
			try {
				request = new DbRequest(DbConstant.admin.session);
				request.select("select "+DbHostConfiguration.Columns.HOSTID.name()+" from "+DbHostConfiguration.table+
						" where "+DbHostConfiguration.Columns.HOSTID+" = '"+Configuration.configuration.HOST_ID+"'");
				request.close();
				DbHostConfiguration.updateVersionDb(session, Configuration.configuration.HOST_ID, R66Versions.V2_4_13.getVersion());
			} catch (WaarpDatabaseSqlException e) {
				return ! upgradeDb(session, version);
			} finally {
				if (request != null) {
					request.close();
				}
			}
		}
		request = null;
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_17.getVersion())) {
			try {
				request = new DbRequest(DbConstant.admin.session);
				request.select("select "+DbTaskRunner.Columns.TRANSFERINFO.name()+" from "+DbTaskRunner.table+
						" where "+DbTaskRunner.Columns.SPECIALID+" = "+DbConstant.ILLEGALVALUE);
				request.close();
				DbHostConfiguration.updateVersionDb(session, Configuration.configuration.HOST_ID, R66Versions.V2_4_17.getVersion());
			} catch (WaarpDatabaseSqlException e) {
				return ! upgradeDb(session, version);
			} finally {
				if (request != null) {
					request.close();
				}
			}
		}
		return false;
	}
	
	
}
]]>
</codefragment>
</duplication>
<duplication lines="48" tokens="274">
<file line="96" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\context\task\ExecMoveTask.java"/>
<file line="102" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\context\task\ExecOutputTask.java"/>
<codefragment>
<![CDATA[
				move(result.status, result.result, finalname);
				localExecClient.disconnect();
				return;
			} // else continue
		}
		String[] args = finalname.split(" ");
		File exec = new File(args[0]);
		if (exec.isAbsolute()) {
			if (!exec.canExecute()) {
				logger.error("Exec command is not executable: " + finalname);
				R66Result result = new R66Result(session, false,
						ErrorCode.CommandNotFound, session.getRunner());
				futureCompletion.setResult(result);
				futureCompletion.cancel();
				return;
			}
		}
		CommandLine commandLine = new CommandLine(args[0]);
		for (int i = 1; i < args.length; i++) {
			commandLine.addArgument(args[i]);
		}
		DefaultExecutor defaultExecutor = new DefaultExecutor();
		PipedInputStream inputStream = new PipedInputStream();
		PipedOutputStream outputStream = null;
		try {
			outputStream = new PipedOutputStream(inputStream);
		} catch (IOException e1) {
			try {
				inputStream.close();
			} catch (IOException e) {
			}
			logger.error("Exception: " + e1.getMessage() +
					" Exec in error with " + commandLine.toString(), e1);
			futureCompletion.setFailure(e1);
			return;
		}
		PumpStreamHandler pumpStreamHandler = new PumpStreamHandler(
				outputStream, null);
		defaultExecutor.setStreamHandler(pumpStreamHandler);
		int[] correctValues = {
				0, 1 };
		defaultExecutor.setExitValues(correctValues);
		ExecuteWatchdog watchdog = null;

		if (delay > 0) {
			watchdog = new ExecuteWatchdog(delay);
			defaultExecutor.setWatchdog(watchdog);
		}
]]>
</codefragment>
</duplication>
<duplication lines="19" tokens="270">
<file line="460" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbRule.java"/>
<file line="488" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbRule.java"/>
<codefragment>
<![CDATA[
	protected void setFromArray() throws WaarpDatabaseSqlException {
		ids = (String) allFields[Columns.HOSTIDS.ordinal()].getValue();
		mode = (Integer) allFields[Columns.MODETRANS.ordinal()].getValue();
		recvPath = (String) allFields[Columns.RECVPATH.ordinal()].getValue();
		sendPath = (String) allFields[Columns.SENDPATH.ordinal()].getValue();
		archivePath = (String) allFields[Columns.ARCHIVEPATH.ordinal()]
				.getValue();
		workPath = (String) allFields[Columns.WORKPATH.ordinal()].getValue();
		rpreTasks = (String) allFields[Columns.RPRETASKS.ordinal()].getValue();
		rpostTasks = (String) allFields[Columns.RPOSTTASKS.ordinal()].getValue();
		rerrorTasks = (String) allFields[Columns.RERRORTASKS.ordinal()]
				.getValue();
		spreTasks = (String) allFields[Columns.SPRETASKS.ordinal()].getValue();
		spostTasks = (String) allFields[Columns.SPOSTTASKS.ordinal()].getValue();
		serrorTasks = (String) allFields[Columns.SERRORTASKS.ordinal()]
				.getValue();
		updatedInfo = (Integer) allFields[Columns.UPDATEDINFO.ordinal()]
				.getValue();
		idRule = (String) allFields[Columns.IDRULE.ordinal()].getValue();
]]>
</codefragment>
</duplication>
<duplication lines="23" tokens="267">
<file line="1482" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\http\adminssl\HttpSslHandler.java"/>
<file line="1621" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\http\adminssl\HttpSslHandler.java"/>
<codefragment>
<![CDATA[
			String system = REQUEST.System.readFileUnique(this);
			StringBuilder builder = new StringBuilder(system);
			WaarpStringUtils.replace(builder, REPLACEMENT.XXXXBUSINESSXXX.toString(),
					config.getBusiness());
			WaarpStringUtils.replace(builder, REPLACEMENT.XXXXROLESXXX.toString(),
					config.getRoles());
			WaarpStringUtils.replace(builder, REPLACEMENT.XXXXALIASESXXX.toString(),
					config.getAliases());
			WaarpStringUtils.replace(builder, REPLACEMENT.XXXXOTHERXXX.toString(),
					config.getOthers());
			WaarpStringUtils.replace(builder, REPLACEMENT.XXXXSESSIONLIMITWXXX.toString(),
					Long.toString(Configuration.configuration.serverChannelWriteLimit));
			WaarpStringUtils.replace(builder, REPLACEMENT.XXXXSESSIONLIMITRXXX.toString(),
					Long.toString(Configuration.configuration.serverChannelReadLimit));
			WaarpStringUtils.replace(builder, REPLACEMENT.XXXXDELAYCOMMDXXX.toString(),
					Long.toString(Configuration.configuration.delayCommander));
			WaarpStringUtils.replace(builder, REPLACEMENT.XXXXDELAYRETRYXXX.toString(),
					Long.toString(Configuration.configuration.delayRetry));
			WaarpStringUtils.replace(builder, REPLACEMENT.XXXXCHANNELLIMITWXXX.toString(),
					Long.toString(Configuration.configuration.serverGlobalWriteLimit));
			WaarpStringUtils.replace(builder, REPLACEMENT.XXXXCHANNELLIMITRXXX.toString(),
					Long.toString(Configuration.configuration.serverGlobalReadLimit));
			WaarpStringUtils.replace(builder, "XXXBLOCKXXX", Configuration.configuration.isShutdown ? "checked" : "");
]]>
</codefragment>
</duplication>
<duplication lines="32" tokens="242">
<file line="287" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="259" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
			String primaryKey = " PRIMARY KEY ";
			String notNull = " NOT NULL ";
	
			// HostConfiguration
			String action = createTableH2 + DbHostConfiguration.table + "(";
			DbHostConfiguration.Columns[] chcolumns = DbHostConfiguration.Columns
					.values();
			for (int i = 0; i < chcolumns.length - 1; i++) {
				action += chcolumns[i].name() +
						DBType.getType(DbHostConfiguration.dbTypes[i]) + notNull +
						", ";
			}
			action += chcolumns[chcolumns.length - 1].name() +
					DBType.getType(DbHostConfiguration.dbTypes[chcolumns.length - 1]) +
					primaryKey + ")";
			System.out.println(action);
			DbRequest request = new DbRequest(session);
			try {
				request.query(action);
			} catch (WaarpDatabaseSqlException e) {
				e.printStackTrace();
				return false;
			} finally {
				request.close();
			}
		}
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_17.getVersion())) {
			System.out.println(version+" to "+R66Versions.V2_4_17.getVersion()+"? "+true);
			String command = "ALTER TABLE "+DbTaskRunner.table+" ADD COLUMN "+
					DbTaskRunner.Columns.TRANSFERINFO.name()+ " "+
					DBType.getType(DbTaskRunner.dbTypes[DbTaskRunner.Columns.TRANSFERINFO.ordinal()]) +  
					" DEFAULT '{}' NOT NULL "+
]]>
</codefragment>
</duplication>
<duplication lines="48" tokens="219">
<file line="1757" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<file line="1841" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<codefragment>
<![CDATA[
	public static boolean setConfigurationServerShutdownFromXml(Configuration config,
			String filename) {
		Document document = null;
		// Open config file
		try {
			document = new SAXReader().read(filename);
		} catch (DocumentException e) {
			logger.error("Unable to read the XML Config file: " + filename, e);
			return false;
		}
		if (document == null) {
			logger.error("Unable to read the XML Config file: " + filename);
			return false;
		}
		configuration = XmlUtil.read(document, configServer);
		hashConfig = new XmlHash(configuration);
		// Now read the configuration
		if (!loadIdentity(config)) {
			logger.error("Cannot load Identity");
			return false;
		}
		if (!loadDatabase(config)) {
			logger.error("Cannot load Database configuration");
			return false;
		}
		if (!loadServerParam(config)) {
			logger.error("Cannot load Server Parameters");
			return false;
		}
		if (!loadDirectory(config)) {
			logger.error("Cannot load Directory configuration");
			return false;
		}
		if (!loadLimit(config, false)) {
			logger.error("Cannot load Limit configuration");
			return false;
		}
		if (config.useSSL) {
			if (!loadSsl(config)) {
				logger.error("Cannot load SSL configuration");
				return false;
			}
		}
		if (!loadNetworkServer(config)) {
			logger.error("Cannot load Network configuration");
			return false;
		}
		if (!DbConstant.admin.isConnected) {
]]>
</codefragment>
</duplication>
<duplication lines="40" tokens="207">
<file line="3561" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbTaskRunner.java"/>
<file line="3743" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbTaskRunner.java"/>
<codefragment>
<![CDATA[
		} catch (FileNotFoundException e) {
			logger.error("Cannot write XML file", e);
			throw new OpenR66ProtocolBusinessException("File not found");
		} catch (UnsupportedEncodingException e) {
			logger.error("Cannot write XML file", e);
			throw new OpenR66ProtocolBusinessException("Unsupported Encoding");
		} finally {
			if (xmlWriter != null) {
				try {
					xmlWriter.endDocument();
					xmlWriter.flush();
					xmlWriter.close();
				} catch (SAXException e) {
					try {
						outputStream.close();
					} catch (IOException e2) {
					}
					File file = new File(filename);
					file.delete();
					logger.error("Cannot write XML file", e);
					throw new OpenR66ProtocolBusinessException("Unsupported Encoding");
				} catch (IOException e) {
					try {
						outputStream.close();
					} catch (IOException e2) {
					}
					File file = new File(filename);
					file.delete();
					logger.error("Cannot write XML file", e);
					throw new OpenR66ProtocolBusinessException("Unsupported Encoding");
				}
			} else if (outputStream != null) {
				try {
					outputStream.close();
				} catch (IOException e) {
				}
				File file = new File(filename);
				file.delete();
			}
		}
]]>
</codefragment>
</duplication>
<duplication lines="29" tokens="207">
<file line="263" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="259" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
			String primaryKey = " PRIMARY KEY ";
			String notNull = " NOT NULL ";
	
			// HostConfiguration
			String action = createTableH2 + DbHostConfiguration.table + "(";
			DbHostConfiguration.Columns[] chcolumns = DbHostConfiguration.Columns
					.values();
			for (int i = 0; i < chcolumns.length - 1; i++) {
				action += chcolumns[i].name() +
						DBType.getType(DbHostConfiguration.dbTypes[i]) + notNull +
						", ";
			}
			action += chcolumns[chcolumns.length - 1].name() +
					DBType.getType(DbHostConfiguration.dbTypes[chcolumns.length - 1]) +
					primaryKey + ")";
			System.out.println(action);
			DbRequest request = new DbRequest(session);
			try {
				request.query(action);
			} catch (WaarpDatabaseSqlException e) {
				e.printStackTrace();
				return false;
			} finally {
				request.close();
			}
		}
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_17.getVersion())) {
			System.out.println(version+" to "+R66Versions.V2_4_17.getVersion()+"? "+true);
			String command = "ALTER TABLE "+DbTaskRunner.table+" ADD COLUMN IF NOT EXISTS "+
]]>
</codefragment>
</duplication>
<duplication lines="49" tokens="205">
<file line="205" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\context\task\ExecMoveTask.java"/>
<file line="201" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\context\task\ExecOutputTask.java"/>
<codefragment>
<![CDATA[
				futureCompletion.setFailure(e);
				return;
			}
		} catch (IOException e) {
			try {
				outputStream.close();
			} catch (IOException e1) {
			}
			thread.interrupt();
			try {
				inputStream.close();
			} catch (IOException e1) {
			}
			pumpStreamHandler.stop();
			logger.error("IOException: " + e.getMessage() +
					" . Exec in error with " + commandLine.toString());
			futureCompletion.setFailure(e);
			return;
		}
		try {
			outputStream.flush();
		} catch (IOException e) {
		}
		try {
			outputStream.close();
		} catch (IOException e) {
		}
		pumpStreamHandler.stop();
		try {
			if (delay > 0) {
				thread.join(delay);
			} else {
				thread.join();
			}
		} catch (InterruptedException e) {
			Thread.currentThread().interrupt();
		}
		try {
			inputStream.close();
		} catch (IOException e1) {
		}
		String newname = null;
		if (defaultExecutor.isFailure(status) && watchdog != null &&
				watchdog.killedProcess()) {
			// kill by the watchdoc (time out)
			status = -1;
			newname = "TimeOut";
		} else {
			newname = lastLineReader.lastLine;
]]>
</codefragment>
</duplication>
<duplication lines="38" tokens="198">
<file line="386" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\http\adminssl\HttpSslHandler.java"/>
<file line="501" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\http\adminssl\HttpSslHandler.java"/>
<codefragment>
<![CDATA[
				body = REQUEST.Listing.readBody();
				DbPreparedStatement preparedStatement = null;
				try {
					preparedStatement =
							DbTaskRunner.getFilterPrepareStatement(dbSession, LIMITROW, false,
									startid, stopid, tstart, tstop, rule, req,
									pending, transfer, error, done, all);
					preparedStatement.executeQuery();
					StringBuilder builder = new StringBuilder();
					int i = 0;
					while (preparedStatement.getNext()) {
						try {
							i++;
							DbTaskRunner taskRunner = DbTaskRunner
									.getFromStatement(preparedStatement);
							LocalChannelReference lcr =
									Configuration.configuration.getLocalTransaction().
											getFromRequest(taskRunner.getKey());
							builder.append(taskRunner.toSpecializedHtml(authentHttp, body,
									lcr != null ? "Active" : "NotActive"));
							if (i > LIMITROW) {
								break;
							}
						} catch (WaarpDatabaseException e) {
							// try to continue if possible
							logger.warn("An error occurs while accessing a Runner: {}",
									e.getMessage());
							continue;
						}
					}
					preparedStatement.realClose();
					body = builder.toString();
				} catch (WaarpDatabaseException e) {
					if (preparedStatement != null) {
						preparedStatement.realClose();
					}
					logger.warn("OpenR66 Web Error {}", e.getMessage());
				}
]]>
</codefragment>
</duplication>
<duplication lines="34" tokens="195">
<file line="110" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\server\LogExport.java"/>
<file line="144" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\server\LogExtendedExport.java"/>
<codefragment>
<![CDATA[
		LocalChannelReference localChannelReference = networkTransaction
				.createConnectionWithRetry(socketAddress, isSSL, future);
		socketAddress = null;
		if (localChannelReference == null) {
			host = null;
			logger.error("Cannot Connect");
			future.setResult(new R66Result(
					new OpenR66ProtocolNoConnectionException("Cannot connect to server"),
					null, true, ErrorCode.Internal, null));
			future.setFailure(future.getResult().exception);
			return;
		}
		localChannelReference.sessionNewState(R66FiniteDualStates.VALIDOTHER);
		try {
			ChannelUtils.writeAbstractLocalPacket(localChannelReference, valid, false);
		} catch (OpenR66ProtocolPacketException e) {
			logger.error("Bad Protocol", e);
			Channels.close(localChannelReference.getLocalChannel());
			localChannelReference = null;
			host = null;
			valid = null;
			future.setResult(new R66Result(e, null, true,
					ErrorCode.TransferError, null));
			future.setFailure(e);
			return;
		}
		host = null;
		future.awaitUninterruptibly();
		logger.info("Request done with " + (future.isSuccess() ? "success" : "error"));
		Channels.close(localChannelReference.getLocalChannel());
		localChannelReference = null;
	}

	protected static boolean spurgeLog = false;
]]>
</codefragment>
</duplication>
<duplication lines="26" tokens="189">
<file line="1317" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<file line="1342" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<codefragment>
<![CDATA[
		} else if ((!packet.getFilename().equals(runner.getOriginalFilename())) 
				&& runner.isSender() && runner.isInTransfer()
				&& runner.getRank() == 0 && (!packet.isToValidate())) {
			// File was modify at the very beginning (using wildcards)
			// and the remote host has already received the request packet
			// => Informs the receiver of the new name
			logger.debug("Will send a modification of filename due to wildcard: " +
					runner.getFilename());
			session.newState(VALID);
			if (localChannelReference.getPartner().useJson()) {
				ObjectNode node = JsonHandler.createObjectNode();
				JsonHandler.setValue(node, JsonCommandPacket.REQUESTPACKET.comment, "Change Filename by Wildcard on sender");
				JsonHandler.setValue(node, JsonCommandPacket.REQUESTPACKET.filename, runner.getFilename());
				JsonHandler.setValue(node, JsonCommandPacket.REQUESTPACKET.filesize, packet.getOriginalSize());
				JsonCommandPacket validPacket = new JsonCommandPacket(node,
						LocalPacketFactory.REQUESTPACKET);
				ChannelUtils.writeAbstractLocalPacket(localChannelReference,
						validPacket, true);
			} else {
				ValidPacket validPacket = new ValidPacket("Change Filename by Wildcard on sender",
					runner.getFilename()+PartnerConfiguration.BAR_SEPARATOR_FIELD+packet.getOriginalSize(), 
					LocalPacketFactory.REQUESTPACKET);
				ChannelUtils.writeAbstractLocalPacket(localChannelReference,
					validPacket, true);
			}
		} else if (runner.isSelfRequest() && runner.isSender() && runner.isInTransfer()
]]>
</codefragment>
</duplication>
<duplication lines="38" tokens="183">
<file line="1640" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<file line="1690" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<codefragment>
<![CDATA[
	public static boolean setConfigurationInitDatabase(Configuration config, String filename) {
		Document document = null;
		// Open config file
		try {
			document = new SAXReader().read(filename);
		} catch (DocumentException e) {
			logger.error("Unable to read the XML Config file: " + filename, e);
			return false;
		}
		if (document == null) {
			logger.error("Unable to read the XML Config file: " + filename);
			return false;
		}
		configuration = XmlUtil.read(document, configServer);
		hashConfig = new XmlHash(configuration);
		if (!loadIdentity(config)) {
			logger.error("Cannot load Identity");
			return false;
		}
		if (!loadDatabase(config)) {
			logger.error("Cannot load Database configuration");
			return false;
		}
		if (!loadDirectory(config)) {
			logger.error("Cannot load Directory configuration");
			return false;
		}
		if (!loadLimit(config, false)) {
			logger.error("Cannot load Limit configuration");
			return false;
		}
		if (!DbConstant.admin.isConnected) {
			// if no database, must load authentication from file
			if (!loadAuthentication(config)) {
				logger.error("Cannot load Authentication configuration");
				return false;
			}
		}
]]>
</codefragment>
</duplication>
<duplication lines="38" tokens="175">
<file line="2284" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<file line="2959" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<codefragment>
<![CDATA[
						ErrorCode.getFromCode(packet.getSmiddle()), null);
				resulttest.other = packet;
				switch (resulttest.code) {
					case CompleteOk:
					case InitOk:
					case PostProcessingOk:
					case PreProcessingOk:
					case QueryAlreadyFinished:
					case QueryStillRunning:
					case Running:
					case TransferOk:
						break;
					default:
						localChannelReference.invalidateRequest(resulttest);
						session.setStatus(102);
						Channels.close(channel);
						return;
				}
				localChannelReference.validateRequest(resulttest);
				session.setStatus(28);
				Channels.close(channel);
				break;
			}
			case LocalPacketFactory.LOGPACKET:
			case LocalPacketFactory.LOGPURGEPACKET: {
				session.newState(VALIDOTHER);
				// should be from the local server or from an authorized hosts: LOGCONTROL
				try {
					if (!session.getAuth().getUser().equals(
							Configuration.configuration.getHostId(session.getAuth().isSsl())) &&
							!session.getAuth().isValidRole(ROLE.LOGCONTROL)) {
						throw new OpenR66ProtocolNotAuthenticatedException(
								"Not correctly authenticated");
					}
				} catch (OpenR66ProtocolNoSslException e1) {
					throw new OpenR66ProtocolNotAuthenticatedException(
							"Not correctly authenticated since SSL is not supported", e1);
				}
]]>
</codefragment>
</duplication>
<duplication lines="32" tokens="164">
<file line="2166" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<file line="2831" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<codefragment>
<![CDATA[
				ValidPacket valid = new ValidPacket(packet.getSmiddle(), resulttest.code.getCode(),
						LocalPacketFactory.REQUESTUSERPACKET);
				resulttest.other = packet;
				localChannelReference.validateRequest(resulttest);
				try {
					ChannelUtils.writeAbstractLocalPacket(localChannelReference,
							valid, true);
				} catch (OpenR66ProtocolPacketException e) {
				}
				session.setStatus(27);
				Channels.close(channel);
				break;
			}
			case LocalPacketFactory.VALIDPACKET: {
				session.newState(VALIDOTHER);
				// should be from the local server or from an authorized hosts: TRANSFER
				try {
					if (!session.getAuth().getUser().equals(
							Configuration.configuration.getHostId(session.getAuth().isSsl())) &&
							!session.getAuth().isValidRole(ROLE.TRANSFER)) {
						throw new OpenR66ProtocolNotAuthenticatedException(
								"Not correctly authenticated");
					}
				} catch (OpenR66ProtocolNoSslException e1) {
					throw new OpenR66ProtocolNotAuthenticatedException(
							"Not correctly authenticated since SSL is not supported", e1);
				}
				// Try to validate a restarting transfer
				// validLimit on requested side
				if (Configuration.configuration.constraintLimitHandler.checkConstraints()) {
					logger.error("Limit exceeded while asking to relaunch a task"
							+ packet.getSmiddle());
]]>
</codefragment>
</duplication>
<duplication lines="29" tokens="164">
<file line="2372" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<file line="3085" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<codefragment>
<![CDATA[
				ValidPacket valid = new ValidPacket(filename + " " + nb, result.code.getCode(),
						LocalPacketFactory.REQUESTUSERPACKET);
				localChannelReference.validateRequest(result);
				try {
					ChannelUtils.writeAbstractLocalPacket(localChannelReference,
							valid, true);
				} catch (OpenR66ProtocolPacketException e) {
				}
				Channels.close(channel);
				break;
			}
			case LocalPacketFactory.CONFEXPORTPACKET: {
				session.newState(VALIDOTHER);
				// Authentication must be the local server or CONFIGADMIN authorization
				try {
					if (!session.getAuth().getUser().equals(
							Configuration.configuration.getHostId(session.getAuth().isSsl())) &&
							!session.getAuth().isValidRole(ROLE.CONFIGADMIN)) {
						throw new OpenR66ProtocolNotAuthenticatedException(
								"Not correctly authenticated");
					}
				} catch (OpenR66ProtocolNoSslException e1) {
					throw new OpenR66ProtocolNotAuthenticatedException(
							"Not correctly authenticated since SSL is not supported", e1);
				}
				if (Configuration.configuration.r66Mib != null) {
					Configuration.configuration.r66Mib.notifyWarning(
							"Export Configuration Order received", session.getAuth().getUser());
				}
]]>
</codefragment>
</duplication>
<duplication lines="29" tokens="164">
<file line="2452" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<file line="3234" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<codefragment>
<![CDATA[
				ValidPacket valid = new ValidPacket(shost + " " + srule, result.code.getCode(),
						LocalPacketFactory.REQUESTUSERPACKET);
				localChannelReference.validateRequest(result);
				try {
					ChannelUtils.writeAbstractLocalPacket(localChannelReference,
							valid, true);
				} catch (OpenR66ProtocolPacketException e) {
				}
				Channels.close(channel);
				break;
			}
			case LocalPacketFactory.CONFIMPORTPACKET: {
				session.newState(VALIDOTHER);
				// Authentication must be the local server or CONFIGADMIN authorization
				try {
					if (!session.getAuth().getUser().equals(
							Configuration.configuration.getHostId(session.getAuth().isSsl())) &&
							!session.getAuth().isValidRole(ROLE.CONFIGADMIN)) {
						throw new OpenR66ProtocolNotAuthenticatedException(
								"Not correctly authenticated");
					}
				} catch (OpenR66ProtocolNoSslException e1) {
					throw new OpenR66ProtocolNotAuthenticatedException(
							"Not correctly authenticated since SSL is not supported", e1);
				}
				if (Configuration.configuration.r66Mib != null) {
					Configuration.configuration.r66Mib.notifyWarning(
							"Import Configuration Order received", session.getAuth().getUser());
				}
]]>
</codefragment>
</duplication>
<duplication lines="42" tokens="163">
<file line="392" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbConfiguration.java"/>
<file line="593" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbHostConfiguration.java"/>
<codefragment>
<![CDATA[
		DbConfiguration dbConfiguration = new DbConfiguration(preparedStatement.getDbSession());
		dbConfiguration.getValues(preparedStatement, dbConfiguration.allFields);
		dbConfiguration.setFromArray();
		dbConfiguration.isSaved = true;
		return dbConfiguration;
	}

	/**
	 * 
	 * @return the DbPreparedStatement for getting Updated Object
	 * @throws WaarpDatabaseNoConnectionException
	 * @throws WaarpDatabaseSqlException
	 */
	public static DbPreparedStatement getUpdatedPrepareStament(DbSession session)
			throws WaarpDatabaseNoConnectionException, WaarpDatabaseSqlException {
		String request = "SELECT " + selectAllFields;
		request += " FROM " + table +
				" WHERE " + Columns.UPDATEDINFO.name() + " = " +
				AbstractDbData.UpdatedInfo.TOSUBMIT.ordinal() +
				" AND " + Columns.HOSTID.name() + " = '" + Configuration.configuration.HOST_ID
				+ "'";
		DbPreparedStatement prep = new DbPreparedStatement(session, request);
		return prep;
	}

	/*
	 * (non-Javadoc)
	 * @see org.waarp.openr66.databaseold.data.AbstractDbData#changeUpdatedInfo(UpdatedInfo)
	 */
	@Override
	public void changeUpdatedInfo(UpdatedInfo info) {
		if (updatedInfo != info.ordinal()) {
			updatedInfo = info.ordinal();
			allFields[Columns.UPDATEDINFO.ordinal()].setValue(updatedInfo);
			isSaved = false;
		}
	}

	/**
	 * Update configuration according to new value of limits
	 */
	public void updateConfiguration() {
]]>
</codefragment>
</duplication>
<duplication lines="21" tokens="163">
<file line="1010" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\http\adminssl\HttpSslHandler.java"/>
<file line="1062" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\http\adminssl\HttpSslHandler.java"/>
<codefragment>
<![CDATA[
			} else if ("TestConn".equalsIgnoreCase(parm)) {
				String host = getTrimValue("host");
				String addr = getTrimValue("address");
				String port = getTrimValue("port");
				String key = getTrimValue("hostkey");
				boolean ssl, admin, isclient;
				ssl = params.containsKey("ssl");
				admin = params.containsKey("admin");
				isclient = params.containsKey("isclient");
				head = resetOptionHosts(head, host, addr, ssl);
                int iport;
				try {
					iport = Integer.parseInt(port);
				} catch (NumberFormatException e1) {
					body0 = body1 = body = "";
                    body = "<p><center><b>Cannot find a Host: "+e1.getMessage()+"</b></center></p>";
                    head = resetOptionHosts(head, "", "", false);
                    return head+body0+body+body1+end;
				}
				DbHostAuth dbhost = new DbHostAuth(dbSession, host, addr, iport,
						ssl, key.getBytes(), admin, isclient);
]]>
</codefragment>
</duplication>
<duplication lines="25" tokens="162">
<file line="243" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\server\ConfigExport.java"/>
<file line="391" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\server\ConfigImport.java"/>
<codefragment>
<![CDATA[
					logger.error("COnfigExport in     FAILURE since Host is not found: "+stohost, e);
					networkTransaction.closeAll();
					System.exit(10);
				}
			} else {
				stohost = Configuration.configuration.HOST_SSLID;
			}
			transaction.run();
			future.awaitUninterruptibly();
			long time2 = System.currentTimeMillis();
			long delay = time2 - time1;
			R66Result result = future.getResult();
			if (future.isSuccess()) {
				boolean useJson = PartnerConfiguration.useJson(stohost);
				logger.debug("UseJson: "+useJson);
				String message = null;
				if (useJson) {
					message = (result.other != null ? ((JsonCommandPacket) result.other).getRequest() :
							"no file");
				} else {
					message = (result.other != null ? ((ValidPacket) result.other).getSheader() :
							"no file");
				}
				if (result.code == ErrorCode.Warning) {
					logger.warn("WARNED on files:     " +
]]>
</codefragment>
</duplication>
<duplication lines="16" tokens="158">
<file line="3625" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<file line="3667" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<codefragment>
<![CDATA[
					R66Result result = new R66Result(session, true, ErrorCode.CompleteOk, null);
					// Now answer
					JsonHandler.setValue(node, JsonCommandPacket.REQUESTUSERPACKET.command, packet.getTypeValid());
					JsonHandler.setValue(node, JsonCommandPacket.BANDWIDTHPACKET.writeglobal, Configuration.configuration.serverGlobalWriteLimit);
					JsonHandler.setValue(node, JsonCommandPacket.BANDWIDTHPACKET.readglobal, Configuration.configuration.serverGlobalReadLimit);
					JsonHandler.setValue(node, JsonCommandPacket.BANDWIDTHPACKET.writesession, Configuration.configuration.serverChannelWriteLimit);
					JsonHandler.setValue(node, JsonCommandPacket.BANDWIDTHPACKET.readsession, Configuration.configuration.serverChannelReadLimit);
					JsonCommandPacket valid = new JsonCommandPacket(node, result.code.getCode(),
							LocalPacketFactory.REQUESTUSERPACKET);
					localChannelReference.validateRequest(result);
					try {
						ChannelUtils.writeAbstractLocalPacket(localChannelReference,
								valid, true);
					} catch (OpenR66ProtocolPacketException e) {
					}
					Channels.close(channel);
]]>
</codefragment>
</duplication>
<duplication lines="25" tokens="155">
<file line="653" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbHostConfiguration.java"/>
<file line="749" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbHostConfiguration.java"/>
<codefragment>
<![CDATA[
	private boolean updateSet(String source, String path, HashSet<String> set) {
		if (source != null && ! source.isEmpty()) {
			Document document = null;
			StringReader reader = null;
			if (source != null && ! source.isEmpty()) {
				try {
					reader = new StringReader(source);
					document = new SAXReader().read(reader);
				} catch (DocumentException e) {
					logger.error("Unable to read the XML Config "+path+" string: " + source, e);
					if (reader != null) {
						reader.close();
					}
					return false;
				}
				if (document == null) {
					logger.error("Unable to read the XML Config "+path+" string: " + source);
					if (reader != null) {
						reader.close();
					}
					return false;
				}
				@SuppressWarnings("unchecked")
				List<Element> list = document.selectNodes(path);
				for (Element element : list) {
]]>
</codefragment>
</duplication>
<duplication lines="21" tokens="154">
<file line="1588" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbTaskRunner.java"/>
<file line="1628" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbTaskRunner.java"/>
<codefragment>
<![CDATA[
			DbSession session, boolean in)
			throws WaarpDatabaseNoConnectionException, WaarpDatabaseSqlException {
		String request = "SELECT COUNT(" + Columns.SPECIALID.name() + ") FROM " + table;
		String requesterd;
		String from = Configuration.configuration.HOST_ID;
		String sfrom = Configuration.configuration.HOST_SSLID;
		if (in) {
			requesterd = Columns.REQUESTED.name();
		} else {
			requesterd = Columns.REQUESTER.name();
		}
		if (from != null & sfrom != null) {
			request += " WHERE ((" + requesterd + " = '" +
					from + "' OR " + requesterd + " = '" + sfrom + "') ";
		} else if (from != null) {
			request += " WHERE (" + requesterd + " = '" + from + "' ";
		} else {
			request += " WHERE (" + requesterd + " = '" + sfrom + "' ";
		}
		request += " AND " + getLimitWhereCondition() + ") ";
		request += " AND " + Columns.STARTTRANS.name() + " >= ? ";
]]>
</codefragment>
</duplication>
<duplication lines="22" tokens="150">
<file line="139" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="142" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="146" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelOracle.java"/>
<file line="135" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
		System.out.println(action);
		request = new DbRequest(session);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			// XXX FIX no return;
		} finally {
			request.close();
		}
				
		// hosts
		action = createTableH2 + DbHostAuth.table + "(";
		DbHostAuth.Columns[] hcolumns = DbHostAuth.Columns.values();
		for (int i = 0; i < hcolumns.length - 1; i++) {
			action += hcolumns[i].name() +
					DBType.getType(DbHostAuth.dbTypes[i]) + notNull + ", ";
		}
		action += hcolumns[hcolumns.length - 1].name() +
				DBType.getType(DbHostAuth.dbTypes[hcolumns.length - 1]) +
]]>
</codefragment>
</duplication>
<duplication lines="22" tokens="150">
<file line="2131" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<file line="2796" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<codefragment>
<![CDATA[
				ErrorCode code = (packet.getTypeValid() == LocalPacketFactory.STOPPACKET) ?
						ErrorCode.StoppedTransfer : ErrorCode.CanceledTransfer;
				if (lcr != null) {
					int rank = 0;
					if (code == ErrorCode.StoppedTransfer && lcr.getSession() != null) {
						DbTaskRunner taskRunner = lcr.getSession().getRunner();
						if (taskRunner != null) {
							rank = taskRunner.getRank();
						}
					}
					session.newState(ERROR);
					ErrorPacket error = new ErrorPacket(code.name() + " " + rank,
							code.getCode(), ErrorPacket.FORWARDCLOSECODE);
					try {
						// XXX ChannelUtils.writeAbstractLocalPacket(lcr, error);
						// inform local instead of remote
						ChannelUtils.writeAbstractLocalPacketToLocal(lcr, error);
					} catch (Exception e) {
					}
					resulttest = new R66Result(session, true,
							ErrorCode.CompleteOk, session.getRunner());
				} else {
]]>
</codefragment>
</duplication>
<duplication lines="25" tokens="146">
<file line="142" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\client\DirectTransfer.java"/>
<file line="171" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\client\MultipleDirectTransfer.java"/>
<codefragment>
<![CDATA[
					rhost, localFilename, rule, fileInfo, ismd5, block, idt,
					networkTransaction);
			logger.debug("rhost: "+rhost+":"+transaction.remoteHost);
			transaction.run();
			future.awaitUninterruptibly();
			long time2 = System.currentTimeMillis();
			logger.debug("finish transfer: " + future.isSuccess());
			long delay = time2 - time1;
			R66Result result = future.getResult();
			if (future.isSuccess()) {
				if (result.runner.getErrorInfo() == ErrorCode.Warning) {
					logger.warn("Transfer in status: WARNED     "
							+ result.runner.toShortString()
							+
							"     <REMOTE>"
							+ rhost
							+ "</REMOTE>"
							+
							"     <FILEFINAL>"
							+
							(result.file != null ? result.file.toString() + "</FILEFINAL>"
									: "no file")
							+ "     delay: " + delay);
				} else {
					logger.info("Transfer in status: SUCCESS     "
]]>
</codefragment>
</duplication>
<duplication lines="22" tokens="146">
<file line="2693" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<file line="3646" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<codefragment>
<![CDATA[
				long rsl = (Long.parseLong(splitsession[1]) / 10) * 10;
				if (wgl < 0) {
					wgl = Configuration.configuration.serverGlobalWriteLimit;
				}
				if (rgl < 0) {
					rgl = Configuration.configuration.serverGlobalReadLimit;
				}
				if (wsl < 0) {
					wsl = Configuration.configuration.serverChannelWriteLimit;
				}
				if (rsl < 0) {
					rsl = Configuration.configuration.serverChannelReadLimit;
				}
				if (Configuration.configuration.r66Mib != null) {
					Configuration.configuration.r66Mib.notifyWarning(
							"Change Bandwidth Limit Order received: Global " +
									wgl + ":" + rgl + " (W:R) Local " + wsl + ":" + rsl + " (W:R)",
							session.getAuth().getUser());
				}
				Configuration.configuration.changeNetworkLimit(wgl, rgl, wsl, rsl,
						Configuration.configuration.delayLimit);
				R66Result result = new R66Result(session, true, ErrorCode.CompleteOk, null);
]]>
</codefragment>
</duplication>
<duplication lines="27" tokens="139">
<file line="194" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\server\LogExport.java"/>
<file line="248" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\server\LogExtendedExport.java"/>
<codefragment>
<![CDATA[
			} else if (args[i].equalsIgnoreCase("-host")) {
				i++;
				stohost = args[i];
			}
		}
		if (ssstart != null) {
			Timestamp tstart = WaarpStringUtils.fixDate(ssstart);
			if (tstart != null) {
				sstart = tstart;
			}
		}
		if (ssstop != null) {
			Timestamp tstop = WaarpStringUtils.fixDate(ssstop, sstart);
			if (tstop != null) {
				sstop = tstop;
			}
		}
		if (ssstart == null && ssstop == null) {
			sstop = WaarpStringUtils.getTodayMidnight();
		}
		return true;
	}

	public static void main(String[] args) {
		InternalLoggerFactory.setDefaultFactory(new WaarpSlf4JLoggerFactory(null));
		if (logger == null) {
			logger = WaarpInternalLoggerFactory.getLogger(LogExport.class);
]]>
</codefragment>
</duplication>
<duplication lines="25" tokens="136">
<file line="228" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelOracle.java"/>
<file line="216" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
		} finally {
			request.close();
		}
		// Index Runner
		action = "CREATE INDEX IDX_RUNNER ON " + DbTaskRunner.table + "(";
		DbTaskRunner.Columns[] icolumns = DbTaskRunner.indexes;
		for (int i = 0; i < icolumns.length - 1; i++) {
			action += icolumns[i].name() + ", ";
		}
		action += icolumns[icolumns.length - 1].name() + ")";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// cptrunner
		action = "CREATE SEQUENCE " + DbTaskRunner.fieldseq +
				" MINVALUE " + (DbConstant.ILLEGALVALUE + 1) +
]]>
</codefragment>
</duplication>
<duplication lines="12" tokens="136">
<file line="701" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\http\adminssl\HttpSslHandler.java"/>
<file line="742" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\http\adminssl\HttpSslHandler.java"/>
<codefragment>
<![CDATA[
					body = REQUEST.CancelRestart.readBody();
					body = taskRunner.toSpecializedHtml(authentHttp, body,
							lcr != null ? "Active" : "NotActive");
					String tstart = taskRunner.getStart().toString();
					tstart = tstart.substring(0, tstart.length());
					String tstop = taskRunner.getStop().toString();
					tstop = tstop.substring(0, tstop.length());
					head = resetOptionTransfer(head, (taskRunner.getSpecialId() - 1) + "",
							(taskRunner.getSpecialId() + 1) + "", tstart, tstop,
							taskRunner.getRuleId(), taskRunner.getRequested(),
							false, false, false, false, true);
				}
]]>
</codefragment>
</duplication>
<duplication lines="22" tokens="135">
<file line="96" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\context\task\ExecMoveTask.java"/>
<file line="102" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\context\task\ExecOutputTask.java"/>
<file line="83" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\context\task\ExecTask.java"/>
<codefragment>
<![CDATA[
				move(result.status, result.result, finalname);
				localExecClient.disconnect();
				return;
			} // else continue
		}
		String[] args = finalname.split(" ");
		File exec = new File(args[0]);
		if (exec.isAbsolute()) {
			if (!exec.canExecute()) {
				logger.error("Exec command is not executable: " + finalname);
				R66Result result = new R66Result(session, false,
						ErrorCode.CommandNotFound, session.getRunner());
				futureCompletion.setResult(result);
				futureCompletion.cancel();
				return;
			}
		}
		CommandLine commandLine = new CommandLine(args[0]);
		for (int i = 1; i < args.length; i++) {
			commandLine.addArgument(args[i]);
		}
		DefaultExecutor defaultExecutor = new DefaultExecutor();
]]>
</codefragment>
</duplication>
<duplication lines="14" tokens="133">
<file line="133" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelOracle.java"/>
<file line="276" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelOracle.java"/>
<codefragment>
<![CDATA[
		action = createTableH2 + DbHostConfiguration.table + "(";
		DbHostConfiguration.Columns[] chcolumns = DbHostConfiguration.Columns
				.values();
		for (int i = 0; i < chcolumns.length - 1; i++) {
			action += chcolumns[i].name() +
					DBType.getType(DbHostConfiguration.dbTypes[i]) + notNull +
					", ";
		}
		action += chcolumns[chcolumns.length - 1].name() +
				DBType.getType(DbHostConfiguration.dbTypes[chcolumns.length - 1]) +
				notNull + ",";
		action += constraint + " hostconf_pk " + primaryKey + "("
				+ chcolumns[chcolumns.length - 1].name() + "))";
		System.out.println(action);
]]>
</codefragment>
</duplication>
<duplication lines="23" tokens="128">
<file line="172" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\server\LogExport.java"/>
<file line="206" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\server\LogExtendedExport.java"/>
<codefragment>
<![CDATA[
					+
					"    -start timestamp in format yyyyMMddHHmmssSSS possibly truncated and where one of ':-. ' can be separators\n"
					+
					"    -stop timestamp in same format than start\n" +
					"If not start and no stop are given, stop is Today Midnight (00:00:00)\n" +
					"If start is equals or greater than stop, stop is start+24H\n"+
					"    -host host (optional)");
			return false;
		}
		String ssstart = null;
		String ssstop = null;
		for (int i = 1; i < args.length; i++) {
			if (args[i].equalsIgnoreCase("-purge")) {
				spurgeLog = true;
			} else if (args[i].equalsIgnoreCase("-clean")) {
				sclean = true;
			} else if (args[i].equalsIgnoreCase("-start")) {
				i++;
				ssstart = args[i];
			} else if (args[i].equalsIgnoreCase("-stop")) {
				i++;
				ssstop = args[i];
			} else if (args[i].equalsIgnoreCase("-host")) {
]]>
</codefragment>
</duplication>
<duplication lines="28" tokens="127">
<file line="1801" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<file line="1888" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<codefragment>
<![CDATA[
			logger.error("Cannot load Network configuration");
			return false;
		}
		if (!DbConstant.admin.isConnected) {
			// if no database, must load authentication from file
			if (!loadAuthentication(config)) {
				logger.error("Cannot load Authentication configuration");
				return false;
			}
		}
		config.HOST_AUTH = R66Auth.getServerAuth(
				DbConstant.admin.session, config.HOST_ID);
		if (config.HOST_AUTH == null &&
				config.useNOSSL) {
			logger.error("Cannot find Authentication for current host");
			return false;
		}
		if (config.HOST_SSLID != null) {
			config.HOST_SSLAUTH = R66Auth.getServerAuth(
					DbConstant.admin.session,
					config.HOST_SSLID);
			if (config.HOST_SSLAUTH == null &&
					config.useSSL) {
				logger.error("Cannot find SSL Authentication for current host");
				return false;
			}
		}
		loadBusinessWhiteList(config);
]]>
</codefragment>
</duplication>
<duplication lines="37" tokens="124">
<file line="2716" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<file line="3674" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<codefragment>
<![CDATA[
				ValidPacket valid = new ValidPacket("Bandwidth changed", result.code.getCode(),
						LocalPacketFactory.REQUESTUSERPACKET);
				localChannelReference.validateRequest(result);
				try {
					ChannelUtils.writeAbstractLocalPacket(localChannelReference,
							valid, true);
				} catch (OpenR66ProtocolPacketException e) {
				}
				Channels.close(channel);
				break;
			}
			case LocalPacketFactory.TESTPACKET: {
				session.newState(VALIDOTHER);
				logger.info("Valid TEST MESSAGE: " + packet.toString());
				R66Result resulttest = new R66Result(session, true,
						ErrorCode.CompleteOk, null);
				resulttest.other = packet;
				localChannelReference.validateRequest(resulttest);
				Channels.close(channel);
				break;
			}
			default:
				logger.info("Validation is ignored: " + packet.getTypeValid());
		}
	}

	/**
	 * Receive a json request
	 * 
	 * @param channel
	 * @param packet
	 * @throws OpenR66ProtocolNotAuthenticatedException
	 * @throws OpenR66RunnerErrorException
	 * @throws OpenR66ProtocolSystemException
	 * @throws OpenR66ProtocolBusinessException
	 */
	private void jsonCommand(Channel channel, JsonCommandPacket packet)
]]>
</codefragment>
</duplication>
<duplication lines="27" tokens="123">
<file line="1718" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<file line="1801" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<file line="1888" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<codefragment>
<![CDATA[
			logger.error("Cannot load Limit configuration");
			return false;
		}
		if (!DbConstant.admin.isConnected) {
			// if no database, must load authentication from file
			if (!loadAuthentication(config)) {
				logger.error("Cannot load Authentication configuration");
				return false;
			}
		}
		config.HOST_AUTH = R66Auth.getServerAuth(
				DbConstant.admin.session, config.HOST_ID);
		if (config.HOST_AUTH == null &&
				config.useNOSSL) {
			logger.error("Cannot find Authentication for current host");
			return false;
		}
		if (config.HOST_SSLID != null) {
			config.HOST_SSLAUTH = R66Auth.getServerAuth(
					DbConstant.admin.session,
					config.HOST_SSLID);
			if (config.HOST_SSLAUTH == null &&
					config.useSSL) {
				logger.error("Cannot find SSL Authentication for current host");
				return false;
			}
		}
]]>
</codefragment>
</duplication>
<duplication lines="31" tokens="121">
<file line="223" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="228" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelOracle.java"/>
<codefragment>
<![CDATA[
		} finally {
			request.close();
		}
		// Index Runner
		action = "CREATE INDEX IDX_RUNNER ON " + DbTaskRunner.table + "(";
		DbTaskRunner.Columns[] icolumns = DbTaskRunner.indexes;
		for (int i = 0; i < icolumns.length - 1; i++) {
			action += icolumns[i].name() + ", ";
		}
		action += icolumns[icolumns.length - 1].name() + ")";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// cptrunner
		/*
		 * # Table to handle any number of sequences: CREATE TABLE Sequences ( name VARCHAR(22) NOT
		 * NULL, seq INT UNSIGNED NOT NULL, # (or BIGINT) PRIMARY KEY name ); # Create a Sequence:
		 * INSERT INTO Sequences (name, seq) VALUES (?, 0); # Drop a Sequence: DELETE FROM Sequences
		 * WHERE name = ?; # Get a sequence number: UPDATE Sequences SET seq = LAST_INSERT_ID(seq +
		 * 1) WHERE name = ?; $seq = $db->LastInsertId();
		 */
		action = "CREATE TABLE Sequences (name VARCHAR(22) NOT NULL PRIMARY KEY," +
]]>
</codefragment>
</duplication>
<duplication lines="24" tokens="120">
<file line="363" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\commander\Commander.java"/>
<file line="481" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\commander\Commander.java"/>
<codefragment>
<![CDATA[
					hostAuth = null;
				}
			} catch (WaarpDatabaseNoConnectionException e) {
				try {
					DbModelFactory.dbModel.validConnection(DbConstant.admin.session);
				} catch (WaarpDatabaseNoConnectionException e1) {
				}
				logger.error("Database No Connection Error: Cannot execute Commander", e);
				return;
			} catch (WaarpDatabaseSqlException e) {
				try {
					DbModelFactory.dbModel.validConnection(DbConstant.admin.session);
				} catch (WaarpDatabaseNoConnectionException e1) {
				}
				logger.error("Database SQL Error: Cannot execute Commander", e);
				return;
			} catch (WaarpDatabaseException e) {
				try {
					DbModelFactory.dbModel.validConnection(DbConstant.admin.session);
				} catch (WaarpDatabaseNoConnectionException e1) {
				}
				logger.error("Database Error: Cannot execute Commander", e);
				return;
			} finally {
]]>
</codefragment>
</duplication>
<duplication lines="24" tokens="119">
<file line="1640" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<file line="1690" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<file line="1757" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<file line="1841" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<codefragment>
<![CDATA[
	public static boolean setConfigurationInitDatabase(Configuration config, String filename) {
		Document document = null;
		// Open config file
		try {
			document = new SAXReader().read(filename);
		} catch (DocumentException e) {
			logger.error("Unable to read the XML Config file: " + filename, e);
			return false;
		}
		if (document == null) {
			logger.error("Unable to read the XML Config file: " + filename);
			return false;
		}
		configuration = XmlUtil.read(document, configServer);
		hashConfig = new XmlHash(configuration);
		if (!loadIdentity(config)) {
			logger.error("Cannot load Identity");
			return false;
		}
		if (!loadDatabase(config)) {
			logger.error("Cannot load Database configuration");
			return false;
		}
		if (!loadDirectory(config)) {
]]>
</codefragment>
</duplication>
<duplication lines="22" tokens="117">
<file line="258" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\commander\Commander.java"/>
<file line="365" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\commander\Commander.java"/>
<file line="483" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\commander\Commander.java"/>
<codefragment>
<![CDATA[
			} catch (WaarpDatabaseNoConnectionException e) {
				try {
					DbModelFactory.dbModel.validConnection(DbConstant.admin.session);
				} catch (WaarpDatabaseNoConnectionException e1) {
				}
				logger.error("Database No Connection Error: Cannot execute Commander", e);
				return;
			} catch (WaarpDatabaseSqlException e) {
				try {
					DbModelFactory.dbModel.validConnection(DbConstant.admin.session);
				} catch (WaarpDatabaseNoConnectionException e1) {
				}
				logger.error("Database SQL Error: Cannot execute Commander", e);
				return;
			} catch (WaarpDatabaseException e) {
				try {
					DbModelFactory.dbModel.validConnection(DbConstant.admin.session);
				} catch (WaarpDatabaseNoConnectionException e1) {
				}
				logger.error("Database Error: Cannot execute Commander", e);
				return;
			} finally {
]]>
</codefragment>
</duplication>
<duplication lines="21" tokens="116">
<file line="138" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\server\ChangeBandwidthLimits.java"/>
<file line="123" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\server\LogExport.java"/>
<file line="157" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\server\LogExtendedExport.java"/>
<codefragment>
<![CDATA[
		try {
			ChannelUtils.writeAbstractLocalPacket(localChannelReference, valid, false);
		} catch (OpenR66ProtocolPacketException e) {
			logger.error("Bad Protocol", e);
			Channels.close(localChannelReference.getLocalChannel());
			localChannelReference = null;
			host = null;
			valid = null;
			future.setResult(new R66Result(e, null, true,
					ErrorCode.TransferError, null));
			future.setFailure(e);
			return;
		}
		host = null;
		future.awaitUninterruptibly();
		logger.info("Request done with " + (future.isSuccess() ? "success" : "error"));
		Channels.close(localChannelReference.getLocalChannel());
		localChannelReference = null;
	}

	protected static long swriteGlobalLimit = -1;
]]>
</codefragment>
</duplication>
<duplication lines="19" tokens="115">
<file line="244" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="240" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
				" START WITH " + (DbConstant.ILLEGALVALUE + 1);
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}
	}

	public boolean upgradeDb(DbSession session, String version) throws WaarpDatabaseNoConnectionException {
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_13.getVersion())) {
			System.out.println(version+" to "+R66Versions.V2_4_13.getVersion()+"? "+true);
			String createTableH2 = "CREATE TABLE IF NOT EXISTS ";
]]>
</codefragment>
</duplication>
<duplication lines="15" tokens="114">
<file line="487" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\http\adminssl\HttpSslHandler.java"/>
<file line="562" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\http\adminssl\HttpSslHandler.java"/>
<codefragment>
<![CDATA[
					all = true;
				}
				Timestamp tstart = WaarpStringUtils.fixDate(start);
				if (tstart != null) {
					start = tstart.toString();
				}
				Timestamp tstop = WaarpStringUtils.fixDate(stop, tstart);
				if (tstop != null) {
					stop = tstop.toString();
				}
				head = resetOptionTransfer(head, startid == null ? "" : startid,
						stopid == null ? "" : stopid, start, stop,
						rule == null ? "" : rule, req == null ? "" : req,
						pending, transfer, error, done, all);
				body = REQUEST.CancelRestart.readBody();
]]>
</codefragment>
</duplication>
<duplication lines="25" tokens="113">
<file line="484" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\context\filesystem\R66File.java"/>
<file line="540" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\context\filesystem\R66File.java"/>
<codefragment>
<![CDATA[
			File newFile = getFileFromPath(path);
			if (newFile.getParentFile().canWrite()) {
				if (!file.renameTo(newFile)) {
					FileOutputStream fileOutputStream;
					try {
						fileOutputStream = new FileOutputStream(newFile);
					} catch (FileNotFoundException e) {
						logger
								.warn("Cannot find file: " + newFile.getName(),
										e);
						return false;
					}
					FileChannel fileChannelOut = fileOutputStream.getChannel();
					if (get(fileChannelOut)) {
						delete();
					} else {
						try {
							fileChannelOut.close();
						} catch (IOException e) {
						}
						logger.error("Cannot write file: {}", newFile);
						return false;
					}
				}
				currentFile = getRelativePath(newFile);
]]>
</codefragment>
</duplication>
<duplication lines="25" tokens="111">
<file line="166" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\client\DirectTransfer.java"/>
<file line="195" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\client\MultipleDirectTransfer.java"/>
<codefragment>
<![CDATA[
					logger.info("Transfer in status: SUCCESS     "
							+ result.runner.toShortString()
							+
							"     <REMOTE>"
							+ rhost
							+ "</REMOTE>"
							+
							"     <FILEFINAL>"
							+
							(result.file != null ? result.file.toString() + "</FILEFINAL>"
									: "no file")
							+ "     delay: " + delay);
				}
				if (nolog) {
					// In case of success, delete the runner
					try {
						result.runner.delete();
					} catch (WaarpDatabaseException e) {
						logger.warn("Cannot apply nolog to     " + result.runner.toShortString(),
								e);
					}
				}
			} else {
				if (result == null || result.runner == null) {
					logger.error("Transfer in     FAILURE with no Id", future.getCause());
]]>
</codefragment>
</duplication>
<duplication lines="12" tokens="111">
<file line="523" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\RuleFileBasedConfiguration.java"/>
<file line="537" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\RuleFileBasedConfiguration.java"/>
<file line="551" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\RuleFileBasedConfiguration.java"/>
<file line="565" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\RuleFileBasedConfiguration.java"/>
<file line="579" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\RuleFileBasedConfiguration.java"/>
<codefragment>
<![CDATA[
		if (array != null) {
			for (rank = 0; rank < array.length; rank++) {
				Element task = new DefaultElement(XTASK);
				task.add(newElement(DbRule.TASK_TYPE, array[rank][0]));
				task.add(newElement(DbRule.TASK_PATH, array[rank][1]));
				task.add(newElement(DbRule.TASK_DELAY, array[rank][2]));
				roottasks.add(task);
			}
		}
		tasks.add(roottasks);
		root.add(tasks);
		tasks = new DefaultElement(XRPOSTTASKS);
]]>
</codefragment>
</duplication>
<duplication lines="15" tokens="111">
<file line="97" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="100" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="101" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelOracle.java"/>
<file line="93" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
		} catch (WaarpDatabaseException e1) {
			e1.printStackTrace();
		}

		// Configuration
		action = createTableH2 + DbConfiguration.table + "(";
		DbConfiguration.Columns[] ccolumns = DbConfiguration.Columns
				.values();
		for (int i = 0; i < ccolumns.length - 1; i++) {
			action += ccolumns[i].name() +
					DBType.getType(DbConfiguration.dbTypes[i]) + notNull +
					", ";
		}
		action += ccolumns[ccolumns.length - 1].name() +
				DBType.getType(DbConfiguration.dbTypes[ccolumns.length - 1]) +
]]>
</codefragment>
</duplication>
<duplication lines="15" tokens="110">
<file line="129" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\client\MultipleSubmitTransfer.java"/>
<file line="115" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\client\SubmitTransfer.java"/>
<codefragment>
<![CDATA[
									host, filename, rule, fileInfo, ismd5, block, idt,
									ttimestart);
							transaction.run();
							future.awaitUninterruptibly();
							DbTaskRunner runner = future.getResult().runner;
							if (future.isSuccess()) {
								logger.warn("Prepare transfer in     SUCCESS     " + runner.toShortString() +
										"<REMOTE>" + rhost + "</REMOTE>");
							} else {
								if (runner != null) {
									logger.error("Prepare transfer in     FAILURE      " + runner.toShortString() +
											"<REMOTE>" + rhost + "</REMOTE>", future.getCause());
								} else {
									logger.error("Prepare transfer in     FAILURE      ", future.getCause());
								}
]]>
</codefragment>
</duplication>
<duplication lines="20" tokens="109">
<file line="224" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="227" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="232" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelOracle.java"/>
<file line="220" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
		action = "CREATE INDEX IF NOT EXISTS IDX_RUNNER ON " + DbTaskRunner.table + "(";
		DbTaskRunner.Columns[] icolumns = DbTaskRunner.indexes;
		for (int i = 0; i < icolumns.length - 1; i++) {
			action += icolumns[i].name() + ", ";
		}
		action += icolumns[icolumns.length - 1].name() + ")";
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			// XXX FIX no return;
		} finally {
			request.close();
		}

		// cptrunner
		action = "CREATE SEQUENCE IF NOT EXISTS " + DbTaskRunner.fieldseq +
]]>
</codefragment>
</duplication>
<duplication lines="12" tokens="109">
<file line="128" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="267" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="131" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="291" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="124" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<file line="263" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
		action = createTableH2 + DbHostConfiguration.table + "(";
		DbHostConfiguration.Columns[] chcolumns = DbHostConfiguration.Columns
				.values();
		for (int i = 0; i < chcolumns.length - 1; i++) {
			action += chcolumns[i].name() +
					DBType.getType(DbHostConfiguration.dbTypes[i]) + notNull +
					", ";
		}
		action += chcolumns[chcolumns.length - 1].name() +
				DBType.getType(DbHostConfiguration.dbTypes[chcolumns.length - 1]) +
				primaryKey + ")";
		System.out.println(action);
]]>
</codefragment>
</duplication>
<duplication lines="15" tokens="109">
<file line="372" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\http\adminssl\HttpSslHandler.java"/>
<file line="562" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\http\adminssl\HttpSslHandler.java"/>
<codefragment>
<![CDATA[
					all = true;
				}
				Timestamp tstart = WaarpStringUtils.fixDate(start);
				if (tstart != null) {
					start = tstart.toString();
				}
				Timestamp tstop = WaarpStringUtils.fixDate(stop, tstart);
				if (tstop != null) {
					stop = tstop.toString();
				}
				head = resetOptionTransfer(head, startid == null ? "" : startid,
						stopid == null ? "" : stopid, start, stop,
						rule == null ? "" : rule, req == null ? "" : req,
						pending, transfer, error, done, all);
				body = REQUEST.Listing.readBody();
]]>
</codefragment>
</duplication>
<duplication lines="21" tokens="108">
<file line="2443" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<file line="2567" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<codefragment>
<![CDATA[
					}
				}
				R66Result result = null;
				if (brule || bhost) {
					result = new R66Result(session, true, ErrorCode.CompleteOk, null);
				} else {
					result = new R66Result(session, true, ErrorCode.TransferError, null);
				}
				// Now answer
				ValidPacket valid = new ValidPacket(shost + " " + srule, result.code.getCode(),
						LocalPacketFactory.REQUESTUSERPACKET);
				localChannelReference.validateRequest(result);
				try {
					ChannelUtils.writeAbstractLocalPacket(localChannelReference,
							valid, true);
				} catch (OpenR66ProtocolPacketException e) {
				}
				Channels.close(channel);
				break;
			}
			case LocalPacketFactory.CONFIMPORTPACKET: {
]]>
</codefragment>
</duplication>
<duplication lines="16" tokens="107">
<file line="143" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\client\Message.java"/>
<file line="179" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\client\RequestInformation.java"/>
<codefragment>
<![CDATA[
			logger.debug("Requested host cannot be found: " + requested);
			R66Result result = new R66Result(null, true, ErrorCode.ConnectionImpossible, null);
			this.future.setResult(result);
			this.future.cancel();
			return;
		}
		if (host.isClient()) {
			logger.error("Requested host is a client and cannot be requested: " + requested);
			R66Result result = new R66Result(null, true, ErrorCode.ConnectionImpossible, null);
			this.future.setResult(result);
			this.future.cancel();
			return;
		}
		SocketAddress socketAddress = host.getSocketAddress();
		boolean isSSL = host.isSsl();
		LocalChannelReference localChannelReference = null;
]]>
</codefragment>
</duplication>
<duplication lines="9" tokens="107">
<file line="603" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<file line="622" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<codefragment>
<![CDATA[
					configNetworkServerDecls, false),
			new XmlDecl(XML_SSL, XmlType.XVAL, XML_ROOT + XML_SSL, configSslDecls, false),
			new XmlDecl(XML_DIRECTORY, XmlType.XVAL, XML_ROOT + XML_DIRECTORY,
					configDirectoryDecls, false),
			new XmlDecl(XML_LIMIT, XmlType.XVAL, XML_ROOT + XML_LIMIT, configLimitDecls, false),
			new XmlDecl(XML_DB, XmlType.XVAL, XML_ROOT + XML_DB, configDbDecls, false),
			new XmlDecl(DbHostConfiguration.XML_BUSINESS, XmlType.STRING, XML_ROOT + DbHostConfiguration.XML_BUSINESS + "/"
					+ DbHostConfiguration.XML_BUSINESSID, true),
			new XmlDecl(DbHostConfiguration.XML_ROLES, XmlType.XVAL, XML_ROOT + DbHostConfiguration.XML_ROLES + "/"
]]>
</codefragment>
</duplication>
<duplication lines="18" tokens="107">
<file line="314" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\context\task\RescheduleTransferTask.java"/>
<file line="361" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\context\task\RescheduleTransferTask.java"/>
<codefragment>
<![CDATA[
				String[] elmts = args[i].split(";");
				boolean startModified = false;
				String[] values = elmts[0].split(":");
				Calendar start = getCalendar(values);
				if (start != null) {
					startModified = true;
				} else {
					start = Calendar.getInstance();
				}
				boolean stopModified = false;
				values = elmts[1].split(":");
				Calendar stop = getCalendar(values);
				if (stop != null) {
					stopModified = true;
				} else {
					stop = Calendar.getInstance();
				}
				logger.debug("Dates before check: Not between " + start.getTime() + " and "
]]>
</codefragment>
</duplication>
<duplication lines="14" tokens="107">
<file line="64" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="67" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="65" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelOracle.java"/>
<file line="60" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
		String primaryKey = " PRIMARY KEY ";
		String notNull = " NOT NULL ";

		// Multiple Mode
		String action = createTableH2 + DbMultipleMonitor.table + "(";
		DbMultipleMonitor.Columns[] mcolumns = DbMultipleMonitor.Columns
				.values();
		for (int i = 0; i < mcolumns.length - 1; i++) {
			action += mcolumns[i].name() +
					DBType.getType(DbMultipleMonitor.dbTypes[i]) + notNull +
					", ";
		}
		action += mcolumns[mcolumns.length - 1].name() +
				DBType.getType(DbMultipleMonitor.dbTypes[mcolumns.length - 1]) +
]]>
</codefragment>
</duplication>
<duplication lines="15" tokens="107">
<file line="123" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="126" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="128" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelOracle.java"/>
<file line="119" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
		} finally {
			request.close();
		}

		// HostConfiguration
		action = createTableH2 + DbHostConfiguration.table + "(";
		DbHostConfiguration.Columns[] chcolumns = DbHostConfiguration.Columns
				.values();
		for (int i = 0; i < chcolumns.length - 1; i++) {
			action += chcolumns[i].name() +
					DBType.getType(DbHostConfiguration.dbTypes[i]) + notNull +
					", ";
		}
		action += chcolumns[chcolumns.length - 1].name() +
				DBType.getType(DbHostConfiguration.dbTypes[chcolumns.length - 1]) +
]]>
</codefragment>
</duplication>
<duplication lines="18" tokens="107">
<file line="269" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="241" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
		System.out.println(action);
		try {
			request.query(action);
		} catch (WaarpDatabaseNoConnectionException e) {
			e.printStackTrace();
			return;
		} catch (WaarpDatabaseSqlException e) {
			e.printStackTrace();
			// XXX FIX no return;
		} finally {
			request.close();
		}
	}

	public boolean upgradeDb(DbSession session, String version) throws WaarpDatabaseNoConnectionException {
		if (PartnerConfiguration.isVersion2GEQVersion1(version, R66Versions.V2_4_13.getVersion())) {
			System.out.println(version+" to "+R66Versions.V2_4_13.getVersion()+"? "+true);
			String createTableH2 = "CREATE TABLE IF NOT EXISTS ";
]]>
</codefragment>
</duplication>
<duplication lines="14" tokens="107">
<file line="263" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="287" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="272" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelOracle.java"/>
<file line="259" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
			String primaryKey = " PRIMARY KEY ";
			String notNull = " NOT NULL ";
	
			// HostConfiguration
			String action = createTableH2 + DbHostConfiguration.table + "(";
			DbHostConfiguration.Columns[] chcolumns = DbHostConfiguration.Columns
					.values();
			for (int i = 0; i < chcolumns.length - 1; i++) {
				action += chcolumns[i].name() +
						DBType.getType(DbHostConfiguration.dbTypes[i]) + notNull +
						", ";
			}
			action += chcolumns[chcolumns.length - 1].name() +
					DBType.getType(DbHostConfiguration.dbTypes[chcolumns.length - 1]) +
]]>
</codefragment>
</duplication>
<duplication lines="11" tokens="106">
<file line="523" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\RuleFileBasedConfiguration.java"/>
<file line="537" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\RuleFileBasedConfiguration.java"/>
<file line="551" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\RuleFileBasedConfiguration.java"/>
<file line="565" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\RuleFileBasedConfiguration.java"/>
<file line="579" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\RuleFileBasedConfiguration.java"/>
<file line="593" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\RuleFileBasedConfiguration.java"/>
<codefragment>
<![CDATA[
		if (array != null) {
			for (rank = 0; rank < array.length; rank++) {
				Element task = new DefaultElement(XTASK);
				task.add(newElement(DbRule.TASK_TYPE, array[rank][0]));
				task.add(newElement(DbRule.TASK_PATH, array[rank][1]));
				task.add(newElement(DbRule.TASK_DELAY, array[rank][2]));
				roottasks.add(task);
			}
		}
		tasks.add(roottasks);
		root.add(tasks);
]]>
</codefragment>
</duplication>
<duplication lines="24" tokens="105">
<file line="147" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\client\AbstractBusinessRequest.java"/>
<file line="87" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\client\BusinessRequest.java"/>
<codefragment>
<![CDATA[
				new BusinessRequestPacket(classname + " " + classarg, 0);
		// XXX FIXME this has to be adapted
		/*
		 * AbstractBusinessRequest transaction = new AbstractBusinessRequest(
		 * AbstractBusinessRequest.class, future, rhost, networkTransaction, packet);
		 * transaction.run(); future.awaitUninterruptibly();
		 */
		long time2 = System.currentTimeMillis();
		logger.debug("Finish Business Request: " + future.isSuccess());
		long delay = time2 - time1;
		if (future.isSuccess()) {
			logger.info("Business Request in status: SUCCESS" +
					"    <REMOTE>" + rhost + "</REMOTE>" +
					"    delay: " + delay);
		} else {
			logger.info("Business Request in status: FAILURE" +
					"    <REMOTE>" + rhost + "</REMOTE>" +
					"    <ERROR>" + future.getCause() + "</ERROR>" +
					"    delay: " + delay);
			networkTransaction.closeAll();
			System.exit(ErrorCode.Unknown.ordinal());
		}
		networkTransaction.closeAll();
	}
]]>
</codefragment>
</duplication>
<duplication lines="27" tokens="105">
<file line="770" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbTaskRunner.java"/>
<file line="808" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbTaskRunner.java"/>
<codefragment>
<![CDATA[
	public void insert() throws WaarpDatabaseException {
		if (isSaved) {
			return;
		}
		if (dbSession == null) {
			if (specialId == DbConstant.ILLEGALVALUE) {
				// New SpecialId is not possible with No Database Model
				createNoDbSpecialId();
			}
			isSaved = true;
			if (Configuration.configuration.saveTaskRunnerWithNoDb) {
				try {
					setToArray();
					this.writeXmlWorkNoDb();
				} catch (OpenR66ProtocolBusinessException e) {
					// Ignore
				}
			}
			if (this.updatedInfo == UpdatedInfo.TOSUBMIT.ordinal()) {
				addNoDb();
			}
			return;
		}
		// First need to find a new id if id is not ok
		if (specialId == DbConstant.ILLEGALVALUE) {
			specialId = DbModelFactory.dbModel.nextSequence(dbSession);
			logger.debug("Try Insert create a new Id from sequence: " +
]]>
</codefragment>
</duplication>
<duplication lines="13" tokens="105">
<file line="171" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelH2.java"/>
<file line="174" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelMysql.java"/>
<file line="179" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelOracle.java"/>
<file line="167" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\model\DbModelPostgresql.java"/>
<codefragment>
<![CDATA[
		} finally {
			request.close();
		}

		// rules
		action = createTableH2 + DbRule.table + "(";
		DbRule.Columns[] rcolumns = DbRule.Columns.values();
		for (int i = 0; i < rcolumns.length - 1; i++) {
			action += rcolumns[i].name() +
					DBType.getType(DbRule.dbTypes[i]) + ", ";
		}
		action += rcolumns[rcolumns.length - 1].name() +
				DBType.getType(DbRule.dbTypes[rcolumns.length - 1]) +
]]>
</codefragment>
</duplication>
<duplication lines="24" tokens="104">
<file line="2261" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<file line="2936" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<codefragment>
<![CDATA[
						valid = new ValidPacket(packet.getSmiddle(),
								ErrorCode.Internal.getCode(),
								LocalPacketFactory.REQUESTUSERPACKET);
						R66Result resulttest = new R66Result(new OpenR66DatabaseGlobalException(e1),
								session, true,
								ErrorCode.Internal, taskRunner);
						resulttest.other = packet;
						localChannelReference.invalidateRequest(resulttest);
					}
				}
				// inform back the requester
				try {
					ChannelUtils.writeAbstractLocalPacket(localChannelReference,
							valid, true);
				} catch (OpenR66ProtocolPacketException e) {
				}
				Channels.close(channel);
				break;
			}
			case LocalPacketFactory.REQUESTUSERPACKET: {
				session.newState(VALIDOTHER);
				// Validate user request
				R66Result resulttest = new R66Result(session, true,
						ErrorCode.getFromCode(packet.getSmiddle()), null);
]]>
</codefragment>
</duplication>
<duplication lines="22" tokens="101">
<file line="1982" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<file line="2040" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\configuration\FileBasedConfiguration.java"/>
<codefragment>
<![CDATA[
		}
		config.HOST_AUTH = R66Auth.getServerAuth(
				DbConstant.admin.session, config.HOST_ID);
		if (config.HOST_AUTH == null) {
			logger.error("Cannot find Authentication for current host");
			return false;
		}
		if (config.HOST_SSLID != null) {
			config.HOST_SSLAUTH = R66Auth.getServerAuth(
					DbConstant.admin.session,
					config.HOST_SSLID);
			if (config.HOST_SSLAUTH == null) {
				logger.error("Cannot find SSL Authentication for current host");
				return false;
			}
		}
		loadBusinessWhiteList(config);
		hashConfig.clear();
		hashConfig = null;
		configuration = null;
		return true;
	}
]]>
</codefragment>
</duplication>
<duplication lines="13" tokens="101">
<file line="744" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbRule.java"/>
<file line="765" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\database\data\DbRule.java"/>
<codefragment>
<![CDATA[
			setFromArrayClone(rule);
			if (recvPath == null || recvPath.trim().isEmpty()) {
				recvPath = Configuration.configuration.inPath;
			}
			if (sendPath == null || sendPath.trim().isEmpty()) {
				sendPath = Configuration.configuration.outPath;
			}
			if (archivePath == null || archivePath.trim().isEmpty()) {
				archivePath = Configuration.configuration.archivePath;
			}
			if (workPath == null || workPath.trim().isEmpty()) {
				workPath = Configuration.configuration.workingPath;
			}
]]>
</codefragment>
</duplication>
<duplication lines="17" tokens="100">
<file line="145" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\context\task\ExecMoveTask.java"/>
<file line="150" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\context\task\ExecOutputTask.java"/>
<codefragment>
<![CDATA[
		Thread thread = new Thread(lastLineReader, "ExecRename"
				+ session.getRunner().getSpecialId());
		thread.setDaemon(true);
		Configuration.configuration.getExecutorService().execute(thread);
		int status = -1;
		try {
			status = defaultExecutor.execute(commandLine);
		} catch (ExecuteException e) {
			if (e.getExitValue() == -559038737) {
				// Cannot run immediately so retry once
				try {
					Thread.sleep(Configuration.RETRYINMS);
				} catch (InterruptedException e1) {
				}
				try {
					status = defaultExecutor.execute(commandLine);
				} catch (ExecuteException e1) {
]]>
</codefragment>
</duplication>
<duplication lines="16" tokens="100">
<file line="2383" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<file line="2463" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<file line="3096" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<file line="3245" path="J:\Git\github\waarp-digest\WaarpR66\src\main\java\org\waarp\openr66\protocol\localhandler\LocalServerHandler.java"/>
<codefragment>
<![CDATA[
			case LocalPacketFactory.CONFEXPORTPACKET: {
				session.newState(VALIDOTHER);
				// Authentication must be the local server or CONFIGADMIN authorization
				try {
					if (!session.getAuth().getUser().equals(
							Configuration.configuration.getHostId(session.getAuth().isSsl())) &&
							!session.getAuth().isValidRole(ROLE.CONFIGADMIN)) {
						throw new OpenR66ProtocolNotAuthenticatedException(
								"Not correctly authenticated");
					}
				} catch (OpenR66ProtocolNoSslException e1) {
					throw new OpenR66ProtocolNotAuthenticatedException(
							"Not correctly authenticated since SSL is not supported", e1);
				}
				if (Configuration.configuration.r66Mib != null) {
					Configuration.configuration.r66Mib.notifyWarning(
]]>
</codefragment>
</duplication>
</pmd-cpd>